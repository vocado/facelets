<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Facelets - JavaServer Faces View Definition Framework</title><link xmlns="" href="css/xhtml.css" rel="stylesheet" type="text/css" /><meta content="DocBook XSL Stylesheets V1.69.0" name="generator" /></head><body><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="N10001" />Facelets - JavaServer Faces View Definition Framework</h1></div><div><h2 class="subtitle">Developer Documentation</h2></div><div><div class="authorgroup"><span class="collab"><span class="collabname">Jacob Hookom</span><br /></span><p class="othercredit"><span class="contrib">Editing and bug
          fixes</span>: <span class="firstname">Ed</span> <span class="surname">Burns</span></p><p class="othercredit"><span class="contrib">Editing</span>: <span class="firstname">Hiroshi</span> <span class="surname">Iwatani</span></p></div></div><div><p class="releaseinfo">1.0.0</p></div></div><div /><hr /></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#intro">Introduction</a></span></dt><dt><span class="preface"><a href="#guide">Documentation Guide</a></span></dt><dt><span class="chapter"><a href="#gettingstarted">1. Getting Started with Facelets</a></span></dt><dd><dl><dt><span class="sect1"><a href="#gettingstarted-download">1.1. Downloading Facelets</a></span></dt><dt><span class="sect1"><a href="#gettingstarted-dependencies">1.2. Dependencies</a></span></dt><dt><span class="sect1"><a href="#gettingstarted-layout">1.3. Directory Structure</a></span></dt><dt><span class="sect1"><a href="#gettingstarted-setup">1.4. Project Setup</a></span></dt><dd><dl><dt><span class="sect2"><a href="#gettingstarted-setup-web">1.4.1. Web.xml Descriptor</a></span></dt><dt><span class="sect2"><a href="#gettingstarted-setup-faces">1.4.2. Faces-Config.xml</a></span></dt></dl></dd><dt><span class="sect1"><a href="#gettingstarted-bean">1.5. The NumberBean</a></span></dt><dd><dl><dt><span class="sect2"><a href="#gettingstarted-bean-java">1.5.1. The Java Code</a></span></dt><dt><span class="sect2"><a href="#gettingstarted-bean-config">1.5.2. Faces Bean Descriptor</a></span></dt></dl></dd><dt><span class="sect1"><a href="#gettingstarted-view">1.6. Creating Web Pages</a></span></dt><dd><dl><dt><span class="sect2"><a href="#gettingstarted-view-template">1.6.1. The Page Template - template.xhtml</a></span></dt><dt><span class="sect2"><a href="#gettingstarted-view-guess">1.6.2. Configuring User Input - guess.xhtml</a></span></dt><dt><span class="sect2"><a href="#gettingstarted-view-response">1.6.3. Displaying the Response - response.xhtml</a></span></dt></dl></dd><dt><span class="sect1"><a href="#gettingstarted-nav">1.7. Handling Navigation</a></span></dt><dt><span class="sect1"><a href="#gettingstarted-deploy">1.8. Deployment</a></span></dt></dl></dd><dt><span class="chapter"><a href="#config">2. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#config-faces">2.1. Configuring JavaServer Faces</a></span></dt><dd><dl><dt><span class="sect2"><a href="#config-faces-ri">2.1.1. JavaServer Faces RI</a></span></dt><dt><span class="sect2"><a href="#config-faces-apache">2.1.2. Apache MyFaces</a></span></dt></dl></dd><dt><span class="sect1"><a href="#config-webapp">2.2. Web Application Descriptors</a></span></dt><dd><dl><dt><span class="sect2"><a href="#config-webapp-init">2.2.1. Initialization Parameters</a></span></dt><dt><span class="sect2"><a href="#config-webapp-security">2.2.2. Security</a></span></dt></dl></dd><dt><span class="sect1"><a href="#config-logging">2.3. Logging</a></span></dt></dl></dd><dt><span class="chapter"><a href="#taglib">3. Tag Libraries</a></span></dt><dd><dl><dt><span class="sect1"><a href="#taglib-use">3.1. Using Tags</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taglib-use-normal">3.1.1. Tag Namespaces</a></span></dt><dt><span class="sect2"><a href="#taglib-use-jsfc">3.1.2. Using 'jsfc'</a></span></dt><dt><span class="sect2"><a href="#taglib-use-unresolved">3.1.3. Unresolved Namespaces</a></span></dt></dl></dd><dt><span class="sect1"><a href="#taglib-available">3.2. Available Tag Libraries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taglib-available-spec">3.2.1. JavaServer Faces Specification</a></span></dt><dt><span class="sect2"><a href="#taglib-available-ui">3.2.2. Templating Library</a></span></dt><dt><span class="sect2"><a href="#taglib-available-jstl">3.2.3. JSTL Support</a></span></dt><dt><span class="sect2"><a href="#taglib-available-adf">3.2.4. Oracle ADF Faces</a></span></dt></dl></dd><dt><span class="sect1"><a href="#taglib-function">3.3. Functions</a></span></dt><dt><span class="sect1"><a href="#taglib-web">3.4. Loading Libraries</a></span></dt><dt><span class="sect1"><a href="#taglib-create">3.5. Creating Tag Libraries</a></span></dt><dd><dl><dt><span class="sect2"><a href="#taglib-create-schema">3.5.1. Tag Library Schema</a></span></dt><dt><span class="sect2"><a href="#taglib-create-component">3.5.2. UIComponents</a></span></dt><dt><span class="sect2"><a href="#taglib-create-validator">3.5.3. Validators</a></span></dt><dt><span class="sect2"><a href="#taglib-create-converter">3.5.4. Converters</a></span></dt><dt><span class="sect2"><a href="#taglib-create-source">3.5.5. Tag (Source) Files</a></span></dt><dt><span class="sect2"><a href="#taglib-create-custom">3.5.6. Custom Tags</a></span></dt><dt><span class="sect2"><a href="#taglib-create-function">3.5.7. Function Specification</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#el">4. Expression Language</a></span></dt><dd><dl><dt><span class="sect1"><a href="#el-inline">4.1. Inlining Text</a></span></dt><dt><span class="sect1"><a href="#el-lifecycle">4.2. EL Lifecycle</a></span></dt></dl></dd><dt><span class="chapter"><a href="#template">5. Templating and Re-Use</a></span></dt><dd><dl><dt><span class="sect1"><a href="#template-detail">5.1. Template/Client Relationships</a></span></dt><dd><dl><dt><span class="sect2"><a href="#template-detail-wrap">5.1.1. Wrapping Content within a Template</a></span></dt><dt><span class="sect2"><a href="#template-detail-piecemeal">5.1.2. Piecemeal Content within a Template</a></span></dt><dt><span class="sect2"><a href="#template-detail-deep">5.1.3. Multi-Level Templating</a></span></dt></dl></dd><dt><span class="sect1"><a href="#template-component">5.2. &lt;ui:component/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-composition">5.3. &lt;ui:composition/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-debug">5.4. &lt;ui:debug/&gt;</a></span></dt><dt><span class="sect1"><a href="#templating-decorate">5.5. &lt;ui:decorate/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-define">5.6. &lt;ui:define/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-fragment">5.7. &lt;ui:fragment/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-include">5.8. &lt;ui:include/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-insert">5.9. &lt;ui:insert/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-param">5.10. &lt;ui:param/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-remove">5.11. &lt;ui:remove/&gt;</a></span></dt><dt><span class="sect1"><a href="#template-repeat">5.12. &lt;ui:repeat/&gt;</a></span></dt></dl></dd><dt><span class="chapter"><a href="#architecture">6. Facelets Architecture</a></span></dt><dd><dl><dt><span class="sect1"><a href="#architecture-views">6.1. View Creation</a></span></dt><dt><span class="sect1"><a href="#architecture-api">6.2. Facelets API</a></span></dt><dd><dl><dt><span class="sect2"><a href="#architecture-api-factory">6.2.1. FaceletFactory</a></span></dt><dt><span class="sect2"><a href="#architecture-api-facelet">6.2.2. Facelet</a></span></dt><dt><span class="sect2"><a href="#architecture-api-handler">6.2.3. FaceletHandler</a></span></dt></dl></dd><dt><span class="sect1"><a href="#architecture-compiler">6.3. Document Compiler</a></span></dt></dl></dd><dt><span class="chapter"><a href="#dev">7. Extending Facelets</a></span></dt><dd><dl><dt><span class="sect1"><a href="#dev-tag">7.1. Tag Development Overview</a></span></dt><dt><span class="sect1"><a href="#dev-taghandler">7.2. Custom TagHandlers</a></span></dt><dt><span class="sect1"><a href="#dev-meta">7.3. Meta Tags</a></span></dt><dd><dl><dt><span class="sect2"><a href="#dev-meta-component">7.3.1. Custom ComponentHandlers</a></span></dt><dt><span class="sect2"><a href="#dev-meta-validator">7.3.2. Custom ValidateHandlers</a></span></dt><dt><span class="sect2"><a href="#dev-meta-converter">7.3.3. Custom ConvertHandlers</a></span></dt></dl></dd><dt><span class="sect1"><a href="#dev-viewHandler">7.4. FaceletViewHandler</a></span></dt><dt><span class="sect1"><a href="#dev-tagdecorators">7.5. Tag Decorators</a></span></dt></dl></dd><dt><span class="chapter"><a href="#building">8. Building Facelets</a></span></dt><dd><dl><dt><span class="sect1"><a href="#building-ant">8.1. Using Ant</a></span></dt><dt><span class="sect1"><a href="#building-ide">8.2. IDE Integration</a></span></dt></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="intro" />Introduction</h2></div></div><div /></div><p>
            The web community is eagerly seeking a light-weight, templating framework backed by JavaServer Faces as the industry standard. While JavaServer Faces and JavaServer Pages technology (<span class="abbrev">JSP</span>) are meant to be aligned, Facelets steps outside of the JSP specification and provides a highly performant, JSF-centric view technology. Anyone who has created a JSP page will be able to do the same with Facelets and familiar XML-tag use. The difference is under the hood where all the burden of the JSP vendor API is removed to greatly enhance JSF as a platform and provide easy plug-and-go development without requiring JSP tag development.
        </p><p>
			JavaServer Faces <code class="literal">UIComponents</code> are first class citizens within Facelets; there's no need to develop extra objects to integrate. There's also no need to learn yet another XML schema to define your views.
		</p><p>
			Facelets includes many features such as:
		</p><div class="itemizedlist"><ul type="disc"><li>
				Works with JSF 1.1 and JSF 1.2, including Sun's RI and Apache MyFaces.
			</li><li>
				Zero Tag development time for UIComponents
			</li><li>
				Fast Templating/Decorators for Components and Pages
			</li><li>
				The ability to specify <code class="literal">UIComponent</code> trees in separate files (<code xmlns="" class="literal">UICompositions</code>)
			</li><li xmlns="">
				Line/Tag/Attribute precise Error Reporting
			</li><li>
				Specify Tags in Separate Files, even packaged with Jars
			</li><li>
				Full EL support, including Functions
			</li><li>
				Build-time EL Validation
			</li><li>
				XML configuration files aren't necessary
			</li><li>
				Reserves the '<code class="literal">jsfc</code>' attribute which acts the same as Tapestry's jwcid (Example: <code xmlns="" class="literal">&lt;input id="bar" type="text" jsfc="h:inputText" value="#{foo.bar}"/&gt;</code>)
			</li><li xmlns="">
				Plugable Decorators to really make designer's job easy (Example: transform <code class="literal">&lt;input type="text"/&gt;</code> to <code xmlns="" class="literal">&lt;h:inputText/&gt;</code> at compile time)
			</li><li xmlns="">
				Works with any <code class="literal">RenderKit</code></li><li xmlns="">
				Facelet APIs aren't dependent on a Web Container
			</li></ul></div><p>
			Everyone wants to be more designer friendly, and Tapestry seems to be the only choice developers are pursuing. On the other hand, JSF is the standard everyone would like to have happen, but JSF needs a more "pluggable" <code class="literal">ViewHandler</code> framework that is both designer and developer friendly.
		</p><p>
			Out of the box, Facelets provides full support for all components specified in the JavaServer Faces specification, including limited support for JSTL tags such as <code class="literal">&lt;c:forEach&gt;</code> and <code class="literal">&lt;c:if&gt;</code>.  Where developers really gain an advantage with using Facelets is its ability to auto-wire additional artifacts to your XML documents such as <code class="literal">UIComponents</code>, <code class="literal">Validators</code>, and <code class="literal">Converters</code>.
		</p><p>
			Facelets is a clean slate for correcting concerns with JSF. Templating, re-use, and ease of development are top priorities that will help bring developers on board with JSF as a suitable platform for large scale projects.
		</p></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="guide" />Documentation Guide</h2></div></div><div /></div><p>
			To get a jump start on development, this guide covers varying degrees of depth.  Please follow these steps:
		</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#gettingstarted" title="Chapter 1. Getting Started with Facelets">Chapter 1, <i>Getting Started with Facelets</i></a>
				as an entry-level tutorial on using
				JavaServer Faces and Facelets together.
				All of the content in this section is
				generic to Faces with the exception of
				<a href="#gettingstarted-view" title="1.6. Creating Web Pages">Section 1.6, “Creating Web Pages”</a>.
				This section describes the simplest
				Facelets templating scenario that could
				possibly work.</p></li><li><p><a href="#config" title="Chapter 2. Configuration">Chapter 2, <i>Configuration</i></a> for details on setting up your web application for use with Facelets.</p></li><li><p><a href="#taglib" title="Chapter 3. Tag Libraries">Chapter 3, <i>Tag Libraries</i></a> for incorporating JSF objects into Facelet documents as tags.</p></li><li><p><a href="#template" title="Chapter 5. Templating and Re-Use">Chapter 5, <i>Templating and Re-Use</i></a> to learn about how Facelets encourages templating and re-use in your documents.</p></li><li><p><a href="#architecture" title="Chapter 6. Facelets Architecture">Chapter 6, <i>Facelets Architecture</i></a> as an overview to the Facelets API and compiler.</p></li><li><p><a href="#dev" title="Chapter 7. Extending Facelets">Chapter 7, <i>Extending Facelets</i></a> as a starting point for extending Facelets functionality with custom tag handlers.</p></li></ul></div><p>
			Additional documentation and resources such as: mailing lists, forums, and announcements, are available on Facelets' home page at:
		</p><div class="itemizedlist"><ul type="disc"><li><p>http://facelets.dev.java.net</p></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="gettingstarted" />Chapter 1. Getting Started with Facelets</h2></div></div><div /></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="gettingstarted-goals" />Tutorial Goals</h2></div></div><div /></div><p>
			This section will walk you through creating a simple Number Guess web application.  Familiarity with Java Web Applications is required along with some knowledge of JavaServer Faces.  For those who are new to those technologies, you can browse:
		</p><div class="itemizedlist"><ul type="disc"><li><p>Java Web Applications - http://www.onjava.com/pub/a/onjava/2001/03/15/tomcat.html</p></li><li><p>JavaServer Faces - http://java.sun.com/j2ee/javaserverfaces/</p></li></ul></div><p>
			The steps in this tutorial are as follows:
		</p><div class="orderedlist"><ol type="1"><li><p><a href="#gettingstarted-download" title="1.1. Downloading Facelets">Section 1.1, “Downloading Facelets”</a> for downloading Facelets binaries or for accessing Facelets source code from CVS.</p></li><li><p><a href="#gettingstarted-dependencies" title="1.2. Dependencies">Section 1.2, “Dependencies”</a> will provide an overview of libraries needed to use JavaServer Faces with Facelets</p></li><li><p><a href="#gettingstarted-layout" title="1.3. Directory Structure">Section 1.3, “Directory Structure”</a> shows the familiar directory structure you should use for this tutorial</p></li><li><p><a href="#gettingstarted-setup" title="1.4. Project Setup">Section 1.4, “Project Setup”</a> has initial configuration settings you need to get up and running</p></li><li><p><a href="#gettingstarted-bean" title="1.5. The NumberBean">Section 1.5, “The NumberBean”</a> details the one JavaBean our tutorial requires and how to use it in JavaServer Faces</p></li><li><p><a href="#gettingstarted-view" title="1.6. Creating Web Pages">Section 1.6, “Creating Web Pages”</a> shows how to create and use a template within JavaServer Faces components</p></li><li><p><a href="#gettingstarted-nav" title="1.7. Handling Navigation">Section 1.7, “Handling Navigation”</a> includes how to tie your views together</p></li><li><p><a href="#gettingstarted-deploy" title="1.8. Deployment">Section 1.8, “Deployment”</a> finishes off the tutorial with deploying your application</p></li></ol></div><p>
			While this tutorial is a little basic for some, you may want to jump back to <a href="#guide" title="Documentation Guide">Documentation Guide</a> for direction.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingstarted-download" />1.1. Downloading Facelets</h2></div></div><div /></div><p>
			Facelets is currently available as a sub-project of the JavaServer Faces Reference Implementation on Java.net (http://facelets.dev.java.net/).  You have a couple options for downloading Facelets:
		</p><div class="itemizedlist"><ul type="disc"><li>
				Download a release binary from http://facelets.dev.java.net/servlets/ProjectDocumentList.  Once downloaded, unzip the project into an appropriate folder.
			</li><li><p>
					If you are a member of Java.net, you may checkout Facelets from CVS.  Make sure you are located in the appropriate directory and use the following CVS commands (Replace <code class="literal">USER_NAME</code> with your Java.net Member Login Name):
				</p><div class="orderedlist"><ol type="1"><li><code class="literal">cvs -d :pserver:USER_NAME@cvs.dev.java.net:/cvs login</code></li><li xmlns=""><code class="literal">cvs -d :pserver:USER_NAME@cvs.dev.java.net:/cvs checkout facelets</code></li></ol></div><p xmlns="">
					More information on accessing Java.net's CVS repository is located at http://facelets.dev.java.net/servlets/ProjectSource. 
				</p></li></ul></div><p>
			See <a href="#building" title="Chapter 8. Building Facelets">Chapter 8, <i>Building Facelets</i></a> for more information on building Facelets from source (specifically if you used CVS).
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingstarted-dependencies" />1.2. Dependencies</h2></div></div><div /></div><p>
			Facelets will work with both version 1.1 and 1.2 of JavaServer Faces and makes no bearing on the implementation used.  Facelets also uses the new EL-API and again can be used with any implementation of that API.  Please reference the table below to make sure your dependencies are available to Facelets:
		</p><div class="table"><a id="N1011D" /><p class="title"><b>Table 1.1. Facelets Dependencies</b></p><table xmlns="" summary="Facelets Dependencies" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>Project</th><th>Build Req?</th><th>Included?</th><th>Description</th><th>Link</th></tr></thead><tbody><tr><td>JavaServer Faces RI</td><td>No</td><td>No</td><td>The reference implementation of JSF 1.1 and JSF 1.2 are available for use with your application.</td><td>http://javaserverfaces.dev.java.net/</td></tr><tr><td>Apache MyFaces</td><td>No</td><td>No</td><td>The alternative to the JSF reference implementation.  MyFaces currently implements the JSF 1.1 specification.</td><td>http://myfaces.apache.org/</td></tr><tr><td>JavaServer Faces 1.2 API</td><td>Yes</td><td>No</td><td>JSF 1.2 API that works with the new EL Specification.  This API is packaged with the JavaServer Faces RI and available on Java.net.</td><td>http://javaserverfaces.dev.java.net/</td></tr><tr><td>EL API</td><td>Yes</td><td>Yes</td><td>The standardized EL specification that is standalone from JSP or JSF, but used by both frameworks.</td><td>http://glassfish.dev.java.net/</td></tr><tr><td>EL RI</td><td>No</td><td>Yes</td><td>The reference implementation that is used by Facelets for handling EL.</td><td>http://glassfish.dev.java.net/</td></tr><tr><td>XML SAX</td><td>Yes</td><td>No</td><td>This dependency should not be an issue for most deployments as it's a standard part of web containers and JREs.</td><td>http://java.sun.com/xml/</td></tr></tbody></table></div><p>
			For more information on using these projects:
		</p><div class="itemizedlist"><ul type="disc"><li><p>
					Those projects that are required to build Facelets, please see <a href="#building" title="Chapter 8. Building Facelets">Chapter 8, <i>Building Facelets</i></a>.
				</p></li><li><p>
					If you would like to use Apache MyFaces with Facelets, see <a href="#config-faces-apache" title="2.1.2. Apache MyFaces">Section 2.1.2, “Apache MyFaces”</a>.
				</p></li><li><p>
					To use Facelets with the JavaServer Faces Reference Implementation, see <a href="#config-faces-ri" title="2.1.1. JavaServer Faces RI">Section 2.1.1, “JavaServer Faces RI”</a>.
				</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingstarted-layout" />1.3. Directory Structure</h2></div></div><div /></div><p>
			Since we are putting together a sample web application, your project should have the following directory structure (presumes JSF RI use):
		</p><pre class="programlisting">$DEPLOY_DIR
+- /WEB-INF
   +- /classes
   +- /lib
      +- /jsf-facelets.jar
      +- /el-api.jar
      +- /el-ri.jar
         [jsf implementation dependencies]
      +- /jsf-api.jar
      +- /jsf-impl.jar
      +- /commons-digester.jar
      +- /commons-logging.jar
      +- /commons-collections.jar
      +- /commons-beanutils.jar
   +- /web.xml
   +- /faces-config.xml
+- /[xhtml documents]
</pre><p>
			For more information on web application deployments in general, there is additional documentation at http://java.sun.com/j2ee and at http://jakarta.apache.org/tomcat.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingstarted-setup" />1.4. Project Setup</h2></div></div><div /></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="gettingstarted-setup-web" />1.4.1. Web.xml Descriptor</h3></div></div><div /></div><p>
				First configure your application's <code class="literal">web.xml</code>.  Make sure that the <code class="literal">FacesServlet</code> is mapped and JSF's <code class="literal">javax.faces.DEFAULT_SUFFIX</code> initialization parameter is specified.  This standard initialization parameter lets JSF know what documents to use for specifying your views.
			</p><pre class="programlisting">&lt;web-app&gt;
		
  &lt;!-- Use Documents Saved as *.xhtml --&gt;	
  &lt;context-param&gt;
    &lt;param-name&gt;javax.faces.DEFAULT_SUFFIX&lt;/param-name&gt;
    &lt;param-value&gt;.xhtml&lt;/param-value&gt;
  &lt;/context-param&gt;
  
  &lt;!-- Special Debug Output for Development --&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;facelets.DEVELOPMENT&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/context-param&gt;
	  
  &lt;!-- Optional JSF-RI Parameters to Help Debug --&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;com.sun.faces.validateXml&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/context-param&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;com.sun.faces.verifyObjects&lt;/param-name&gt;
    &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/context-param&gt;
	  
  &lt;!-- Faces Servlet --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;javax.faces.webapp.FacesServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
	  
  &lt;!-- Faces Servlet Mapping --&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;Faces Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.jsf&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
	  
&lt;/web-app&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="gettingstarted-setup-faces" />1.4.2. Faces-Config.xml</h3></div></div><div /></div><p>
				JavaServer Faces is extremely interoperable with other frameworks.  Most of this flexibility lies in JSF's <code class="literal">Application</code> composite which includes: a default <code class="literal">ActionListener</code>, <code class="literal">ELResolver</code>, <code class="literal">StateManager</code>, <code class="literal">NavigationHandler</code>, and <code class="literal">ViewHandler</code>.  Facelets is used as the application's <code class="literal">ViewHandler</code>, represented by the class <code class="literal">com.sun.facelets.FaceletViewHandler</code>.
			</p><p>
				To configure JavaServer Faces to use Facelets as the <code class="literal">ViewHandler</code>, modify your project's <code class="literal">faces-config.xml</code> to specify the <code class="literal">&lt;view-handler&gt;</code> element:
			</p><pre class="programlisting">&lt;faces-config&gt;		
  &lt;application&gt;
    &lt;view-handler&gt;
      com.sun.facelets.FaceletViewHandler
    &lt;/view-handler&gt;    
  &lt;/application&gt; 
&lt;/faces-config&gt;</pre><p>
				Even though there are other parts to the <code class="literal">faces-config.xml</code> needed for this tutorial, only the <code class="literal">&lt;view-handler&gt;</code> element is required for Facelets use.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingstarted-bean" />1.5. The NumberBean</h2></div></div><div /></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="gettingstarted-bean-java" />1.5.1. The Java Code</h3></div></div><div /></div><p>
				We will have a simple, straight-forward JavaBean that will act as our 'controller' for our NumberGuess tutorial.  Note that the desired class name will be <code class="literal">tutorial.NumberBean</code>.
			</p><pre class="programlisting">package tutorial;

import java.io.Serializable;

import java.util.Random;

import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.context.FacesContext;
import javax.faces.validator.ValidatorException;

public class NumberBean implements Serializable {

  protected final static Random rand = new Random();

  protected int min;
  protected int max;
  protected int guess;
  protected int actual;
    
  // Default Constructor
  public NumberBean() {
    this.min = 1;
    this.max = 10;
  }
   
  // called by JSF to validate user input
  public void validate(FacesContext context, UIComponent component, Object value)
      throws ValidatorException {
      
    // coerce the value to an int
    try {
      int param = Integer.parseInt(value.toString());
    
      // validate param
      if (param &gt; this.max || param &lt; this.min) {
          FacesMessage msg = new FacesMessage("Guess must be between "+this.min+" and "+this.max);
          throw new ValidatorException(msg);
      }
    } catch (NumberFormatException e) {
      FacesMessage msg = new FacesMessage("Must be a number");
      throw new ValidatorException(msg);
    }
  }
    
  // lazy generate our actual value
  public synchronized int getActual() {
    if (this.actual == 0) {
        this.actual = rand.nextInt(this.max-this.min);
        this.actual += this.min;
    }
    return this.actual;
  }
  
  // our message for the response
  public String getMessage() {    
    if (this.guess == this.getActual()) {
      return "Sweet, you got it right!";
    } else if (this.guess &lt; this.getActual()) {
      return "Sorry, try something higher";
    } else {
      return "Too bad, go lower";
    }
  }
  
  // other bean properties
  public int getMin() { return this.min; }
  public int getMax() { return this.max; }
  public int getGuess() { return this.guess; }
    
  public void setMin(int min) { this.min = min; }
  public void setMax(int max) { this.max = max; }
  public void setGuess(int guess) { this.guess = guess; }
    
}</pre><p>
				The above class should be compiled with Java and located at <code class="literal">$DEPLOY_DIR/WEB-INF/classes/tutorial/NumberBean.class</code>.  If you do not know how to compile Java classes, please stop this tutorial and go to http://java.sun.com for introductory help.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="gettingstarted-bean-config" />1.5.2. Faces Bean Descriptor</h3></div></div><div /></div><p>
				You can map JavaBeans into your JavaServer Faces application via the <code class="literal">faces-config.xml</code>.  JavaBeans used in your application can be wired together by bean properties and can be provided scope: a single <code class="literal">request</code>, a whole <code class="literal">session</code> visit, for everyone in the <code class="literal">application</code>, or <code class="literal">none</code> if you don't want it stored directly.
			</p><pre class="programlisting">&lt;faces-config&gt;
			
  &lt;!-- from project setup --&gt;
  &lt;application&gt;
    &lt;view-handler&gt;
      com.sun.facelets.FaceletViewHandler
    &lt;/view-handler&gt;    
  &lt;/application&gt;
  
  &lt;!-- our NumberBean we just created --&gt;
  &lt;managed-bean&gt;
    &lt;managed-bean-name&gt;NumberBean&lt;/managed-bean-name&gt;
    &lt;managed-bean-class&gt;tutorial.NumberBean&lt;/managed-bean-class&gt;
    &lt;managed-bean-scope&gt;session&lt;/managed-bean-scope&gt;
    &lt;managed-property&gt;
      &lt;property-name&gt;min&lt;/property-name&gt;
      &lt;value&gt;1&lt;/value&gt;
    &lt;/managed-property&gt;
    &lt;managed-property&gt;
      &lt;property-name&gt;max&lt;/property-name&gt;
      &lt;value&gt;10&lt;/value&gt;
    &lt;/managed-property&gt;
  &lt;/managed-bean&gt;

&lt;/faces-config&gt;</pre></div><p>
			The <code class="literal">&lt;managed-bean&gt;</code> element above tells JSF to guarantee a <code class="literal">tutorial.NumberBean</code> is available under the attribute name <code class="literal">NumberBean</code> in the user's <code class="literal">session</code>.  In addition, we've allowed our <code class="literal">NumberBean</code> to be configured by setting the <code class="literal">min</code> and <code class="literal">max</code> values a user can guess.  It should be noted that JavaServer Faces will lazy load our <code class="literal">NumberBean</code> when it's first accessed by our application.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingstarted-view" />1.6. Creating Web Pages</h2></div></div><div /></div><p>This section contains the only content the
                "Getting Started" chapter that is entirely specific to
                Facelets.</p><p>
			Facelets emphasizes its ability to template content in your application.  Templating promotes re-use and eases long term maintenance of your application, allowing content to be changed in one spot, but used in multiple pages.  While using templating features wouldn't be necessary for this simple application, it does serve as a tutorial.  For more information on this topic, see <a href="#template" title="Chapter 5. Templating and Re-Use">Chapter 5, <i>Templating and Re-Use</i></a>.
		</p><p>
			We will create three documents: a template page, a page for user input, and finally a page to display a response:
		</p><pre class="programlisting">$DEPLOY_DIR
+- /WEB-INF
   [newly added pages below]
+- /template.xhtml
+- /guess.xhtml
+- /response.xhtml
</pre><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="gettingstarted-view-template" />1.6.1. The Page Template - template.xhtml</h3></div></div><div /></div><p>
				Facelets comes with a library of UI (user interface) tags to use in writing your application.  We will only focus on using a couple of them in creating a page called <code class="literal">template.xhtml</code>.
			</p><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /&gt;
&lt;title&gt;Facelets: Number Guess Tutorial&lt;/title&gt;
&lt;style type="text/css"&gt;
&lt;!--
body {
  font-family: Verdana, Arial, Helvetica, sans-serif;
  font-size: small;
}
--&gt;
&lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h1&gt;
  &lt;ui:insert name="title"&gt;Default Title&lt;/ui:insert&gt;
&lt;/h1&gt;
&lt;p&gt;
  &lt;ui:insert name="body"&gt;Default Body&lt;/ui:insert&gt;
&lt;/p&gt;
&lt;/body&gt;

&lt;/html&gt;</pre><p>
				Facelets requires valid XML markup.  Our sample application is using valid XHTML since these documents will be used on the web. You can even view this document within your favorite visual tool.  A couple things to take notice of:
			</p><div class="orderedlist"><ol type="1"><li><p>Use of proper namespaces such as <code class="literal">xmlns:ui="http://java.sun.com/jsf/facelet"</code> to specify tag libraries loaded by Facelets.  In this example, we are declaring that Facelet's own UI library of tags will be prefixed with a <code class="literal">ui</code>.  Namespace definitions need to be specified before you use a tag from that library, otherwise Facelets will properly error when it compiles your document.</p></li><li><p><code class="literal">&lt;ui:insert&gt;</code> is used to declare parts of the document that can be inserted or overwritten.  If a document doesn't override the insertion point with the specified name (<code class="literal">title</code> or <code class="literal">body</code>), then the default text from the original template is used.</p></li></ol></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="gettingstarted-view-guess" />1.6.2. Configuring User Input - guess.xhtml</h3></div></div><div /></div><p>
				In this example page, we will incorporate components from the JavaServer Faces standard component libraries.
			</p><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:h="http://java.sun.com/jsf/html"&gt;
&lt;body&gt;

This text above will not be displayed.

&lt;ui:composition template="/template.xhtml"&gt;

This text will not be displayed.

  &lt;ui:define name="title"&gt;
    I'm thinking of a number from #{NumberBean.min} to #{NumberBean.max}.  Can you guess it?
  &lt;/ui:define&gt;

This text will also not be displayed.

  &lt;ui:define name="body"&gt;
    &lt;h:form id="helloForm"&gt;
      &lt;h:inputText type="text" id="userNo" value="#{NumberBean.guess}" validator="#{NumberBean.validate}"/&gt;
      &lt;br/&gt;
      &lt;h:commandButton type="submit" id="submit" action="success" value="Submit" /&gt;
      &lt;br/&gt;
      &lt;h:message showSummary="true" showDetail="false" style="color: red; font-weight: bold;" id="errors1" for="userNo"/&gt;
    &lt;/h:form&gt;
  &lt;/ui:define&gt;

This text will not be displayed.
  
&lt;/ui:composition&gt;

This text below will also not be displayed.

&lt;/body&gt;
&lt;/html&gt;</pre><div class="orderedlist"><ol type="1"><li><p>Using a <code class="literal">&lt;ui:composition&gt;</code> tag will trim everything outside of it.  This means that you can create/edit your documents with a visual editor, but Facelets will only use what's between the <code class="literal">&lt;ui:composition&gt;</code> tags.</p></li><li><p>The <code class="literal">&lt;ui:composition&gt;</code> uses the <code class="literal">template</code> attribute to reference the template or look and feel of this page.</p></li><li><p>Two
				<code class="literal">&lt;ui:define&gt;</code>
				tags are specified with names that match
				the ones used in the template we had
				created.  This means that when Facelets
				builds your page, those blocks of
				content will be placed appropriately in
				the template.  Any text that happens to
				reside inside the
				<code class="literal">&lt;ui:composition&gt;</code>
				tag, but outside of the
				<code class="literal">&lt;ui:define&gt;</code>
				tags is not displayed in the rendered
				output.  </p></li><li><p>Facelets also can use 'inlined' EL
				Expressions to make outputting dynamic
				content extremely easy.  In the example
				above,
				<code class="literal">#{NumberBean.max}</code>
				will display the <code class="literal">max</code>
				property of the
				<code class="literal">NumberBean</code> in your
				session.  EL expressions may also reside
				outside tag attributes, in the space
				between tags, but you must keep in mind
				that the result of evaluating the
				expression will only appear in the
				rendered output if template text in that
				same position would appear.</p></li></ol></div><p>
			If you have questions or do not understand the attributes used for <code class="literal">&lt;h:inputText&gt;</code>, <code class="literal">&lt;h:commandButton&gt;</code>, or <code class="literal">&lt;h:message&gt;</code>; documentation on those components are available at http://java.sun.com/j2ee/javaserverfaces.  Keep in mind that Facelets uses the same attributes, behavior, and naming conventions as the tags specified for JavaServer Faces' JSP TLD documents.
		</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="gettingstarted-view-response" />1.6.3. Displaying the Response - response.xhtml</h3></div></div><div /></div><p>
				Finally, if a user entered valid input as specified by the <code class="literal">NumberBean.validate</code> method, then we need a page to give them feedback on their guess.
			</p><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:h="http://java.sun.com/jsf/html"&gt;
&lt;body&gt;

&lt;ui:composition template="/template.xhtml"&gt;

  &lt;ui:define name="title"&gt;
    #{NumberBean.message}
  &lt;/ui:define&gt;
  
  &lt;ui:define name="body"&gt;
    &lt;form jsfc="h:form"&gt;
    &lt;input jsfc="h:commandButton" type="submit" id="back" value="Back" action="success"/&gt;
    &lt;/form&gt;
  &lt;/ui:define&gt;
  
&lt;/ui:composition&gt;

&lt;/body&gt;
&lt;/html&gt;</pre><div class="orderedlist"><ol type="1"><li><p>Again we use an <code class="literal">&lt;ui:composition&gt;</code> to trim unecessary content from our page and use the <code class="literal">template.xhtml</code>.</p></li><li><p>We also introduced the <code class="literal">jsfc</code> attribute which allows the XHTML tags to be compiled into <code class="literal">&lt;h:form&gt;</code> and <code class="literal">&lt;h:commandButton&gt;</code> when the page is compiled.  This means that a designer's visual editor will render a normal form and button, but it will be transformed into a dynamic <code class="literal">UIComponent</code> when compiled by Facelets.</p></li></ol></div><p>
				That's it for the pages.  Again, if you have questions about JavaServer Faces components or would like some additional background, visit http://java.sun.com/j2ee/javaserverfaces
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingstarted-nav" />1.7. Handling Navigation</h2></div></div><div /></div><p>
			We would like to tie our two pages together from <code class="literal">guess.xhtml</code> to <code class="literal">response.xhtml</code> and back again.  To do this, we need to go back into the <code class="literal">faces-config.xml</code> to specify navigation cases.
		</p><pre class="programlisting">&lt;faces-config&gt;
			
  &lt;!-- from project setup --&gt;
  &lt;application&gt;
    &lt;view-handler&gt;
      com.sun.facelets.FaceletViewHandler
    &lt;/view-handler&gt;    
  &lt;/application&gt;
  
  &lt;!-- our NumberBean we created before --&gt;
  &lt;managed-bean&gt;
    &lt;managed-bean-name&gt;NumberBean&lt;/managed-bean-name&gt;
    &lt;managed-bean-class&gt;tutorial.NumberBean&lt;/managed-bean-class&gt;
    &lt;managed-bean-scope&gt;session&lt;/managed-bean-scope&gt;
    &lt;managed-property&gt;
      &lt;property-name&gt;min&lt;/property-name&gt;
      &lt;value&gt;1&lt;/value&gt;
    &lt;/managed-property&gt;
    &lt;managed-property&gt;
      &lt;property-name&gt;max&lt;/property-name&gt;
      &lt;value&gt;10&lt;/value&gt;
    &lt;/managed-property&gt;
  &lt;/managed-bean&gt;
  
  &lt;!-- going from guess.xhtml to response.xhtml --&gt;
  &lt;navigation-rule&gt;
    &lt;from-view-id&gt;/guess.xhtml&lt;/from-view-id&gt;
    &lt;navigation-case&gt;
      &lt;from-outcome&gt;success&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/response.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
  &lt;/navigation-rule&gt;

  &lt;!-- going from response.xhtml to guess.xhtml --&gt;
  &lt;navigation-rule&gt;
    &lt;from-view-id&gt;/response.xhtml&lt;/from-view-id&gt;
    &lt;navigation-case&gt;
        &lt;from-outcome&gt;success&lt;/from-outcome&gt;
      &lt;to-view-id&gt;/guess.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
  &lt;/navigation-rule&gt;

&lt;/faces-config&gt;</pre><p>
			In both pages, we included <code class="literal">commandButtons</code> in some form with <code class="literal">action</code> attributes specified.  The <code class="literal">action</code> attribute is mapped to the <code class="literal">&lt;from-outcome&gt;</code> element in your <code class="literal">faces-config.xml</code>.  This method of handling navigation is extremely flexible and more information on this aspect of JavaServer Faces is included at http://java.sun.com/j2ee/javaserverfaces.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="gettingstarted-deploy" />1.8. Deployment</h2></div></div><div /></div><p>
			Finally, you should be able to deploy all of these artifacts now to your web application.  Your application should generate a random number and allow you to flip between your <code class="literal">guess</code> page and <code class="literal">response</code> page.  To access your application, remember that the <code class="literal">javax.faces.web.FacesServlet</code> in your <code class="literal">web.xml</code> was mapped to <code class="literal">*.jsf</code>.  To start your guessing fun, point your browser to <code class="literal">http://localhost:8080/numberguess/guess.jsf</code> (presuming you used the application name <code class="literal">numberguess</code>).
		</p><p>
			If you have additional problems or questions, going to Facelet's home page at http://facelets.dev.java.net will provide you with additional resources such as forums, mailing lists, and additional documentation.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="config" />Chapter 2. Configuration</h2></div></div><div /></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="config-faces" />2.1. Configuring JavaServer Faces</h2></div></div><div /></div><p>
			Facelets comes with an extensible <code class="literal">ViewHandler</code>.  This is the only necessary integration point within your <code class="literal">faces-config.xml</code>.			
		</p><pre class="programlisting">&lt;faces-config&gt;		
  &lt;application&gt;
    &lt;view-handler&gt;
      com.sun.facelets.FaceletViewHandler
    &lt;/view-handler&gt;    
  &lt;/application&gt; 
&lt;/faces-config&gt;</pre><p>
			The <code class="literal">FaceletViewHandler</code> utilizes several <code class="literal">&lt;context-param&gt;</code> declarations in your <code class="literal">web.xml</code> which are detailed in <a href="#config-webapp-init" title="2.2.1. Initialization Parameters">Section 2.2.1, “Initialization Parameters”</a>.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="config-faces-ri" />2.1.1. JavaServer Faces RI</h3></div></div><div /></div><p>
				See <a href="#gettingstarted" title="Chapter 1. Getting Started with Facelets">Chapter 1, <i>Getting Started with Facelets</i></a> for a tutorial that uses JavaServer Faces RI as an example.  More information on the JSF RI is available at:
			</p><div class="itemizedlist"><ul type="disc"><li><p>http://javaserverfaces.dev.java.net</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="config-faces-apache" />2.1.2. Apache MyFaces</h3></div></div><div /></div><p>
				Apache MyFaces has it's own version of the JavaServer Faces API included in its distribution.  Currently, Apache MyFaces is only up to the 1.1 specification, but has not yet passed the TCK.
			</p><div class="itemizedlist"><ul type="disc"><li><p>http://myfaces.apache.org</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="config-webapp" />2.2. Web Application Descriptors</h2></div></div><div /></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="config-webapp-init" />2.2.1. Initialization Parameters</h3></div></div><div /></div><p>
				  These parameters help with development and increase the flexibility of Facelet use.
			</p><div class="table"><a id="N10390" /><p class="title"><b>Table 2.1. Web.xml Parameter List</b></p><table xmlns="" summary="Web.xml Parameter List" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Parameter Name</th><th>Default Value</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>facelets.LIBRARIES</td><td> </td><td>A semicolon (<code class="literal">;</code>) delimitted list of paths to Facelet tag libraries, relative to your application's root.  These libraries will be loaded when the first request hits the <code xmlns="" class="literal">FaceletViewHandler</code> for page compilation.</td><td xmlns="">/WEB-INF/facelets/foo.taglib.xml; /WEB-INF/facelets/bar.taglib.xml</td></tr><tr><td>facelets.DECORATORS</td><td> </td><td>A semicolon (<code class="literal">;</code>) delimitted list of class names of type <code xmlns="" class="literal">com.sun.facelets.tag.TagDecorator</code>, with a no-argument constructor.  These decorators will be loaded when the first request hits the <code xmlns="" class="literal">FaceletViewHandler</code> for page compilation.</td><td xmlns="">com.sun.facelets.tag.jsf.html.HtmlDecorator</td></tr><tr><td>facelets.DEVELOPMENT</td><td>false</td><td>Setting this to true will cause the <code class="literal">FaceletViewHandler</code> to print out debug information in an easy to use screen when an error occurs during the rendering process.</td><td xmlns="">true</td></tr><tr><td>facelets.BUFFER_SIZE</td><td>-1</td><td>The buffer size to set on the response when the <code class="literal">ResponseWriter</code> is generated.  By default the value is -1, which will not assign a buffer size on the response.  This should be increased if you are using development mode in order to guarantee that the response isn't partially rendered when an error is generated.</td><td xmlns="">8192</td></tr><tr><td>facelets.REFRESH_PERIOD</td><td>2</td><td>When a page is requested, what interval in <code class="literal">seconds</code> should the compiler check for changes.  If you don't want the compiler to check for changes once the page is compiled, then use a value of <code xmlns="" class="literal">-1</code>. Setting a low refresh period helps during development to be able to edit pages in a running application.</td><td xmlns="">-1</td></tr><tr><td>facelets.RESOURCE_RESOLVER</td><td>com.sun.facelets.impl.DefaultResourceResolver</td><td>Optionally provide an alternate ResourceResolver that will replace the default logic of allowing the FacesContext resolve the resource URL.</td><td>my.company.IDEResourceResolver</td></tr><tr><td>facelets.VIEW_MAPPINGS</td><td> </td><td>A semicolon (<code class="literal">;</code>) delimitted list of resources that Facelets should use.  If no resource paths are specified, Facelets will handle all requests (DEFAULT). If one or more paths are specified, Facelets will only use the ones specified, otherwise fall back on the parent or default <code xmlns="" class="literal">ViewHandler</code> (JSP).  Note, this requires the FacesServlet in your <code xmlns="" class="literal">web.xml</code> to be mapped with a prefix for capturing multiple file types ex: <code xmlns="" class="literal">/faces/*</code>.</td><td xmlns="">/demos/*; *.xhtml</td></tr><tr><td>facelets.SKIP_COMMENTS</td><td>true</td><td>A boolean value that tells the compiler to skip comments (default is true).  Even if you comment out code in your page, the tags will not be compiled but expressions (EL) will be treated as if they were inlined-- still compiled and evaluated for output in the document.  Skipping comments will remove all comments completely from the document.</td><td>false</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="config-webapp-security" />2.2.2. Security</h3></div></div><div /></div><p>
				Java applications can restrict access to resources or pages by outside users.  This feature is common to all application servers and part of the Servlet specification.
			</p><p>
				Lets presume that you want to take advantage of developing simple Facelet XHTML documents that are viewable in your browser during development.  When your application is deployed to production, you don't want anyone from the outside to access your XHTML documents unless they are served through the JavaServer Faces Servlet.
			</p><pre class="programlisting">&lt;web-app&gt;
			
  &lt;!-- servlets and such would be above --&gt;

  &lt;security-constraint&gt;	 
    &lt;display-name&gt;Restrict XHTML Documents&lt;/display-name&gt;
    &lt;web-resource-collection&gt;
      &lt;web-resource-name&gt;XHTML&lt;/web-resource-name&gt;
      &lt;url-pattern&gt;*.xhtml&lt;/url-pattern&gt;
    &lt;/web-resource-collection&gt;
    &lt;auth-constraint&gt;
      &lt;description&gt;Only Let 'developer's access XHTML pages&lt;/description&gt;
      &lt;role-name&gt;developer&lt;/role-name&gt;
    &lt;/auth-constraint&gt;
  &lt;/security-constraint&gt;

&lt;/web-app&gt;</pre><p>
				You can read more about Security in the Web Tier at http://java.sun.com/webservices/docs/1.3/tutorial/doc/Security2.html
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="config-logging" />2.3. Logging</h2></div></div><div /></div><p>
			Facelets uses <code class="literal">java.util.Logger</code> for handling logging.  This was done to reduce library dependencies while taking advantage of many Servlet container's ability to modify logging levels on the fly.
		</p><p>
			For many, using the JDK 1.4 <code class="literal">java.util.Logger</code> will be new to them.  You can read more on it at http://java.sun.com/j2se/1.4.2/docs/guide/util/logging/index.html
		</p><div class="table"><a id="N10436" /><p class="title"><b>Table 2.2. Facelet Logger Names</b></p><table xmlns="" summary="Facelet Logger Names" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>facelets.compiler</td><td>For outputting debug information about the compilation process.  This would include namespace resolution for TagLibraries and XML events.  Most of the output will be <code class="literal">FINE</code>.</td></tr><tr xmlns=""><td>facelets.factory</td><td>Information about the inner workings of the <code class="literal">FaceletFactory</code>.</td></tr><tr xmlns=""><td>facelets.tag.component</td><td>Debug information that helps with component lifecycles in relation to Facelets.</td></tr><tr><td>facelets.viewhandler</td><td>Will output view-id mapping/resolution and the states of your views.</td></tr></tbody></table></div><p>
			For those who are currently developing a Facelets project and would like to have all the debug information available on both your application server and in your IDE; modify the <code class="literal">logging.properties</code> in your <code class="literal">JRE/lib</code> directory and add the following lines to the end of that file:
		  </p><pre class="programlisting">facelets.level = FINEST

# uncomment any of the below

#facelets.compiler.level = SEVERE
#facelets.tag.component.level = INFO
#facelets.viewhandler.level = SEVERE</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="taglib" />Chapter 3. Tag Libraries</h2></div></div><div /></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="taglib-use" />3.1. Using Tags</h2></div></div><div /></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-use-normal" />3.1.1. Tag Namespaces</h3></div></div><div /></div><p>
				Facelets uses valid XML with namespace support for compilation.  If you are new to XML, there are great resources online, such as http://www.w3schools.com.  To use a library of tags, you would 'include' the library by declaring a namespace.  Declaring a namespace involves using the library's URI (or URL) and mapping it to a prefix.
			</p><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://java.sun.com/jsf/html"&gt;
      
&lt;body&gt;
  &lt;h:inputText value="#{hello.world}"/&gt;
&lt;/body&gt;

&lt;/html&gt;</pre><p>
			In the example above, we've declared 2 namespaces:
		</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">xmlns="http://www.w3.org/1999/xhtml"</code> Says every tag without a prefix, such as <code class="literal">&lt;body&gt;</code>, are part of XHTML.</p></li><li><p><code class="literal">xmlns:h="http://java.sun.com/jsf/html"</code> Maps the prefix <code class="literal">h:</code> to the JSF HTML library.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-use-jsfc" />3.1.2. Using 'jsfc'</h3></div></div><div /></div><p>
				Facelets provides you the ability to have one XML element in the page be converted to another at compile time by specifying the <code class="literal">jsfc</code> attribute.
			</p><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://java.sun.com/jsf/html"&gt;
      
&lt;body&gt;
  &lt;input type="text" jsfc="h:inputText" value="#{hello.world}" /&gt;
&lt;/body&gt;

&lt;/html&gt;</pre><p>
				The <code class="literal">&lt;input&gt;</code> tag above is readable/displayable in browsers and visual tools as a normal text field.  It would be nice to use that same text field in JavaServer Faces, so we provide the <code class="literal">jsfc="h:inputText"</code>.  This declaration tells the compiler to resolve the <code class="literal">&lt;input&gt;</code> tag as an <code class="literal">&lt;h:inputText&gt;</code> (the same as above).  Note, the same rules for namespaces and naming apply to the value of the <code class="literal">jsfc</code> attribute.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-use-unresolved" />3.1.3. Unresolved Namespaces</h3></div></div><div /></div><p>
				If there is a tag in your document under a namespace (such as XHTML) that isn't specified in a Tag Library, then Facelets will treat that tag as a simple text fragment and optimize it for tree creation.  If the namespace is known, but the element's name isn't included in the tag library, then an exception will be thrown which will tell you what file and line caused the problem.
			</p><p>
				If your tag or component isn't showing up in your rendered page, check the source of page and see if the tag was simply ignored. This usually means you are using the wrong namespace for your library.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="taglib-available" />3.2. Available Tag Libraries</h2></div></div><div /></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-available-spec" />3.2.1. JavaServer Faces Specification</h3></div></div><div /></div><p>
				Facelets comes with support for all tags (components) included in the JavaServer Faces Specification.  Great care was taken to mimic the specification's JSP tag counterparts to leverage existing knowledge and available documentation.  For development, you may reference the 'Tag Library Documentation' at:
			</p><div class="itemizedlist"><ul type="disc"><li>http://java.sun.com/j2ee/javaserverfaces/reference/api/index.html</li></ul></div><div class="table"><a id="N104CB" /><p class="title"><b>Table 3.1. Specification Tag Libraries</b></p><table xmlns="" summary="Specification Tag Libraries" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Namespace</th><th>Description</th></tr></thead><tbody><tr><td>http://java.sun.com/jsf/core</td><td>The core JavaServer Faces custom actions that are independent of any RenderKit used.</td></tr><tr><td>http://java.sun.com/jsf/html</td><td>This tag library contains JavaServer Faces component tags for all UIComponent + HTML RenderKit Renderer combinations defined in the JavaServer Faces Specification.</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-available-ui" />3.2.2. Templating Library</h3></div></div><div /></div><p>
				You can read all about the cool templating features in Facelets in <a href="#template" title="Chapter 5. Templating and Re-Use">Chapter 5, <i>Templating and Re-Use</i></a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-available-jstl" />3.2.3. JSTL Support</h3></div></div><div /></div><p>
				Facelets includes limited support for JSTL 'tags' within the Core and Function library only.  Here is the link to Function and Core documentation from JSTL:
			</p><div class="itemizedlist"><ul type="disc"><li>http://java.sun.com/products/jsp/jstl/1.1/docs/tlddocs/index.html</li></ul></div><p>The Function library is implemented, according to the spec in its entirety.  The Core library has the following implementations:</p><div class="table"><a id="N104F5" /><p class="title"><b>Table 3.2. &lt;c:if/&gt;</b></p><table xmlns="" summary="&lt;c:if/&gt;" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>var</td><td>false</td><td>An optional expression variable to store the result of evaluating the 'test' attribute.</td><td>result</td></tr><tr><td>test</td><td>true</td><td>A required expression that evaluates to a boolean for deciding if the body of this tag is included in tree creation.  Note, an expression evaluating to <code class="literal">null</code> is also false.</td><td xmlns="">#{user.roles['admin']}</td></tr></tbody></table></div><div class="table"><a id="N1051B" /><p class="title"><b>Table 3.3. &lt;c:forEach/&gt;</b></p><table xmlns="" summary="&lt;c:forEach/&gt;" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>var</td><td>false</td><td>An optional expression variable to store the actual currently indexed value.</td><td>employee</td></tr><tr><td>items</td><td>false</td><td>An expression that evaluates to an indexable Collection, Array, or Map.</td><td>#{empDao.employees}</td></tr><tr><td>varStatus</td><td>false</td><td>Variable to bind an Object that describes the current indexed state.  The Object has the following properties: first[boolean], last[boolean], begin[int], end[int], index[int], step[int].</td><td>idx</td></tr><tr><td>begin</td><td>false</td><td>Index the forEach should start at.</td><td>#{param.offset}</td></tr><tr><td>end</td><td>false</td><td>Index the forEach should end at</td><td>#{param.offset + param.pageSize}</td></tr><tr><td>step</td><td>false</td><td>The step size to skip entries in the collection</td><td>2</td></tr></tbody></table></div><div class="table"><a id="N10561" /><p class="title"><b>Table 3.4. &lt;c:catch/&gt;</b></p><table xmlns="" summary="&lt;c:catch/&gt;" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>var</td><td>false</td><td>An optional value to store the Exception Object</td><td>exp</td></tr></tbody></table></div><div class="table"><a id="N1057A" /><p class="title"><b>Table 3.5. &lt;c:set/&gt; (Avoid if Possible)</b></p><table xmlns="" summary="&lt;c:set/&gt; (Avoid if Possible)" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>var</td><td>true</td><td>A variable to store the 'value' expression</td><td>aList</td></tr><tr><td>value</td><td>true</td><td>An expression that will be bound under the specified 'var' attribute.  Anytime this 'var' shows up in other expression, this 'value' will be embeded in the succeeding expression.  The example here would bind 'aList' as "the list within the map under the key 'listA'", NOT as a List Object.  Every time 'aList' is used, it will evaluate the example expression to generate the instance.</td><td>#{listMap['listA']}</td></tr></tbody></table></div><p>
				A note about EL within this JSTL implementation.  Since all set variables from these tags are backed by the new EL API, the only scope they can bind to is within the current <code class="literal">FaceletContext</code>, no others.  This means that variables only can exist for the benefit of creating the component tree for JSF and do not work to assign variables in other scopes.  The reason for this is that the Expressions are actually bound to the FaceletContext, not the evaluted Object.  This is to better serve JSF tree creation.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-available-adf" />3.2.4. Oracle ADF Faces</h3></div></div><div /></div><p>
				Oracle ADF Faces is unofficially supported by Facelets.  This work is being done by independent contributions and is available from the Facelet's home page under documents and files.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="taglib-function" />3.3. Functions</h2></div></div><div /></div><p>
			As part of the EL Specification, you can incorporate <code class="literal">static</code> Java methods into your documents.  The JSTL library already has some of these functions available, see <a href="#taglib-available-jstl" title="3.2.3. JSTL Support">Section 3.2.3, “JSTL Support”</a>.
		</p><p>
			Functions are declared within EL in the following format: <code class="literal">#{fn:sizeOf(myCollection)}</code>.  What that line says is to reference the tag library using the prefix <code class="literal">fn</code> for a function named <code class="literal">sizeOf</code>.  This syntax should feel similar to what's required for using tags from imported libraries.
		</p><p>
			Any tag library can offer any amount of functions.  Please reference the particular library's documentation for function names and parameters information.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="taglib-web" />3.4. Loading Libraries</h2></div></div><div /></div><p>
			Tag libraries can be loaded multiple ways.  First Facelets will load all libraries from your classpath (including packaged Jars) and then any libraries you have specified in your <code class="literal">web.xml</code>.
		</p><div class="itemizedlist"><ul type="disc"><li><p>
					When Facelets searches the classpath, it will attempt to load any file with the extension <code class="literal">*.taglib.xml</code> from the <code class="literal">/meta-inf</code> folder of your Jars.  For example, <code class="literal">/meta-inf/mycompany.taglib.xml</code> would be found by Facelets while <code class="literal">/mycompany.taglib.xml</code> and <code class="literal">/meta-inf/mycompany.xml</code> would not.  See <a href="#config-logging" title="2.3. Logging">Section 2.3, “Logging”</a> for information on recieving debug information on the libraries loaded.
				</p></li><li><p>
					Facelets will check for an initialization parameter from your <code class="literal">web.xml</code> and load all libraries specified there relative to your application's root. See <a href="#config-webapp-init" title="2.2.1. Initialization Parameters">Section 2.2.1, “Initialization Parameters”</a> for details on the parameter.  This is an ideal way to declare specialized tags for a particular application; tags that aren't necessarily distributed with code in Jars.
				</p></li></ul></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="taglib-create" />3.5. Creating Tag Libraries</h2></div></div><div /></div><div class="preface" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-create-overview" />Overview</h3></div></div><div /></div><p>
				Facelets allows you to configure custom tag libraries in a short amount of time.  This section will focus on defining tag libraries in XML which can be automatically loaded by Facelets compiler as described in <a href="#taglib-web" title="3.4. Loading Libraries">Section 3.4, “Loading Libraries”</a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-create-schema" />3.5.1. Tag Library Schema</h3></div></div><div /></div><p>
				The schema (or DTD) for Facelets is extremely simple.  Future releases of Facelets will actually just use your <code class="literal">faces-config.xml</code> files the same way a visual tool would for determining required attributes and namespaces.
			</p><p>
				Facelets currently uses the following doc type:
			</p><pre class="programlisting">&lt;!DOCTYPE facelet-taglib PUBLIC
  "-//Sun Microsystems, Inc.//DTD Facelet Taglib 1.0//EN"
  "http://java.sun.com/dtd/facelet-taglib_1_0.dtd"&gt;</pre><p>
				This is the (simple) DTD that Facelets uses:
			</p><pre class="programlisting">&lt;!ELEMENT facelet-taglib (library-class|(namespace,(tag|function)+))&gt;
&lt;!ATTLIST facelet-taglib xmlns CDATA #FIXED "http://java.sun.com/JSF/Facelet"&gt;
&lt;!ELEMENT namespace (#PCDATA)&gt;
&lt;!ELEMENT library-class (#PCDATA)&gt;
&lt;!ELEMENT tag (tag-name,(handler-class|component|converter|validator|source))&gt;
&lt;!ELEMENT tag-name (#PCDATA)&gt;
&lt;!ELEMENT handler-class (#PCDATA)&gt;
&lt;!ELEMENT component (component-type,renderer-type?,handler-class?)&gt;
&lt;!ELEMENT component-type (#PCDATA)&gt;
&lt;!ELEMENT renderer-type (#PCDATA)&gt;
&lt;!ELEMENT converter (converter-id, handler-class?)&gt;
&lt;!ELEMENT converter-id (#PCDATA)&gt;
&lt;!ELEMENT validator (validator-id, handler-class?)&gt;
&lt;!ELEMENT validator-id (#PCDATA)&gt;
&lt;!ELEMENT source (#PCDATA)&gt;
&lt;!ELEMENT function (function-name,function-class,function-signature)&gt;
&lt;!ELEMENT function-name (#PCDATA)&gt;
&lt;!ELEMENT function-class (#PCDATA)&gt;
&lt;!ELEMENT function-signature (#PCDATA)&gt;</pre><p>
				As you can see, JSF entities are treated as first class citizens in Facelets' tag libraries.  A couple things to observe from the schema above:
			</p><div class="itemizedlist"><ul type="disc"><li><p>
					The definition of a tag library (including namespace) can be delegated to the class specified in the <code class="literal">library-class</code> element.  The class specified must implement <code class="literal">com.sun.facelets.tag.TagLibrary</code>.  This is useful if you would like to maintain your tag library in Java, but would like to have it automatically picked up by the compiler by placing an XML file in your Jar's <code class="literal">meta-inf</code> folder.
				</p></li><li><p>
					Each document (not specified by <code class="literal">library-class</code>) requires a <code class="literal">namespace</code> element which will match the namespace used in your document, see <a href="#taglib-use-normal" title="3.1.1. Tag Namespaces">Section 3.1.1, “Tag Namespaces”</a>.
				</p></li><li><p>
					The rest of the document is made up of <code class="literal">tag</code> and <code class="literal">function</code> elements.  Tag elements require a <code class="literal">tag-name</code> and can take on different behavior depending on what you would like Facelets to handle for you.  Functions can also be specified under the library's namespaces and follow the same signature as in JSP TLD files.
				</p></li></ul></div><p>
				The following sections describe how to integrate your objects within the XML tag library.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-create-component" />3.5.2. UIComponents</h3></div></div><div /></div><p>
				<code class="literal">UIComponents</code> can be auto-wired by using the <code class="literal">component</code> element in your tag library.
			</p><pre class="programlisting">&lt;tag&gt;
  &lt;tag-name&gt;bar&lt;/tag-name&gt;
  &lt;component&gt;
    &lt;component-type&gt;com.mycompany.Data&lt;/component-type&gt;
    &lt;renderer-type&gt;com.mycompany.Bar&lt;/renderer-type&gt;
  &lt;/component&gt;
&lt;/tag&gt;</pre><p>
				In the above example, we are binding a component of type (not Class) <code class="literal">com.mycompany.Data</code> to the tag name <code class="literal">bar</code>.  A <code class="literal">renderer-type</code> is also provided, but not required since <code class="literal">UIComponents</code> can easily render themselves.
			</p><p>
				Based on if your component implements
				<code class="literal">ActionSource[2]</code>,
				<code class="literal">ValueHolder</code>, or
				<code class="literal">EditableValueHolder</code>,
				Facelets will take care of auto-wiring
				those standard attributes according to
				the specification.  Facelets differs
				greatly from JSP in this important
				regard, and this difference is a feature
				of Facelets that takes advantage of the
				dynamism in JavaServer Faces that is
				wasted on JSP.  Specifically, any tag
				attribute in a Facelets page is
				tolerated.  If the value of the
				attribute is a ValueExpression, and tag
				is associated with a UIComponent, the
				expression is stored in the components's
				ValueExpression Map.  Otherwise,
				Facelets looks for a JavaBeans property
				on the component whose name is equal to
				the tag attribute name.  If it exists,
				its setter is called with the value of
				the tag attribute.  If it doesn't exist,
				an entry is created in the generic
				attribute set for the component, the
				value of which is the value of the tag
				attribute.  The upshot of all this is
				that turnaround time is greatly reduced
				because you can modify the component
				and/or renderer without having to change
				a TLD.  Of course, the downside is that
				any attribute is legal, but errors in
				that regard are logged in the logging
				system.</p><p>This approach exemplifies a
                                general philosophy of Facelets, sensible
                                default behavior from the perspective of
                                the page developer.</p><p>The attribute wiring behavior also
                                applies to validators, EL expressions,
                                converters, etc.  Any additional
                                properties on your component will also
                                be wired for you too, just as JSP sets
                                the properties on a
                                <code class="literal">JspTag</code>.  If you think
                                that Facelets can't handle the special
                                wiring your component needs, then skip
                                to <a href="#dev-meta-component" title="7.3.1. Custom ComponentHandlers">Section 7.3.1, “Custom ComponentHandlers”</a>.
			</p><p>
				If you've just created a <code class="literal">UIComponent</code> from scratch and you are not sure how to integrate it into JavaServer Faces, here's all the code you need:
			</p><pre class="programlisting">&lt;faces-config&gt;
  &lt;component&gt;
    &lt;component-type&gt;com.mycompany.Data&lt;/component-type&gt;
    &lt;component-class&gt;com.mycompany.jsf.components.UIDataComponent&lt;/component-class&gt;
  &lt;/component&gt;
&lt;/faces-config&gt;</pre><p>
				Notice that the <code class="literal">component-type</code> matches the one used in the Facelets tag library XML.  This degree of indirection by referencing components by type increases the maintainability and portability of JavaServer Faces components.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-create-validator" />3.5.3. Validators</h3></div></div><div /></div><p>
				<code class="literal">Validators</code> can also be added to Facelets with the <code class="literal">validator</code> element.
			</p><pre class="programlisting">&lt;tag&gt;
  &lt;tag-name&gt;validateEmail&lt;/tag-name&gt;
  &lt;validator&gt;
    &lt;validator-id&gt;faces.validator.Email&lt;/validator-id&gt;
  &lt;/validator&gt;
&lt;/tag&gt;</pre><p>
				Again, we reference JSF entities by type or id.  Facelets will also take care of wiring attributes directly to your <code class="literal">Validator</code> by matching attribute name to property name.  If you would like to provide special behavior or wire odd properties, you can jump ahead to <a href="#dev-meta-validator" title="7.3.2. Custom ValidateHandlers">Section 7.3.2, “Custom ValidateHandlers”</a>.
			</p><p>
				If you've just written your own <code class="literal">Validator</code>, you can add it to your JSF Application with the following snippet in your <code class="literal">faces-config.xml</code>:
			</p><pre class="programlisting">&lt;faces-config&gt;
  &lt;validator&gt;
    &lt;validator-id&gt;faces.validator.Email&lt;/validator-id&gt;
    &lt;handler-class&gt;com.mycompany.jsf.validate.EmailValidator&lt;/handler-class&gt;
  &lt;/validator&gt;
&lt;/faces-config&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-create-converter" />3.5.4. Converters</h3></div></div><div /></div><p>
				<code class="literal">Converters</code> can be registered with Facelets by adding a <code class="literal">converter</code> element.
			</p><pre class="programlisting">&lt;tag&gt;
  &lt;tag-name&gt;convertMoney&lt;/tag-name&gt;
  &lt;converter&gt;
    &lt;converter-id&gt;faces.convert.Money&lt;/converter-id&gt;
  &lt;/converter&gt;
&lt;/tag&gt;</pre><p>
				Converters are referenced by id.  Facelets will take care of wiring attributes directly to your <code class="literal">Converter</code> by matching attribute name to property name.  If you would like to provide special behavior or wire odd properties, you can jump ahead to <a href="#dev-meta-converter" title="7.3.3. Custom ConvertHandlers">Section 7.3.3, “Custom ConvertHandlers”</a>.
			</p><p>
				If you've just written your own <code class="literal">Converter</code>, you can add it to your JSF Application with the following snippet in your <code class="literal">faces-config.xml</code>:
			</p><pre class="programlisting">&lt;faces-config&gt;
  &lt;converter&gt;
    &lt;converter-id&gt;faces.convert.Money&lt;/converter-id&gt;
    &lt;handler-class&gt;com.mycompany.jsf.convert.ConvertMoney&lt;/handler-class&gt;
  &lt;/converter&gt;
&lt;/faces-config&gt;</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-create-source" />3.5.5. Tag (Source) Files</h3></div></div><div /></div><p>
				Facelets has a feature similar to JSP's Tag Files.  Within your tag library definition, you can provide a <code class="literal">source</code> element that points to a another file, that will be compiled into another Facelet.  Since this file can be referenced by <code class="literal">tag-name</code>, you can easily include that Facelets into another and pass variable data to it.
			</p><pre class="programlisting">&lt;tag&gt;
  &lt;tag-name&gt;echo&lt;/tag-name&gt;
  &lt;source&gt;tags/echo.xhtml&lt;/source&gt;
&lt;/tag&gt;</pre><p>
				The <code class="literal">echo.xhtml</code> will be included anytime a developer uses the <code class="literal">echo</code> tag.  The following is an example tag file:
			</p><pre class="programlisting">&lt;ui:composition xmlns:ui="http://java.sun.com/jsf/facelets"&gt;
  &lt;span class="message"&gt;#{msg}&lt;/span&gt;
&lt;/ui:composition&gt;</pre><p>
				This tag file can be included and any variable used within the tag file can be passed as an attribute:
			</p><pre class="programlisting">&lt;my:echo msg="#{bean.warningMessage}"/&gt;</pre><p>
				In this example, the <code class="literal">msg</code> attribute is assigned to <code class="literal">#{bean.warningMessage}</code> and then referenceable within <code class="literal">echo.xhtml</code> under the variable <code class="literal">msg</code>.
			</p><p>
				This was a simple example, but you can do some fairly cool things with building reusable components in your pages.  Going one step further, you may provide a body to your custom tag, by placing a <code class="literal">&lt;ui:insert/&gt;</code> as a place for body inclusion.  See <a href="#template" title="Chapter 5. Templating and Re-Use">Chapter 5, <i>Templating and Re-Use</i></a> for more information.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-create-custom" />3.5.6. Custom Tags</h3></div></div><div /></div><p>
				Facelets allows you to write stateless tags that can be used in dictating component tree creation.  This includes JSTL-like functionality that may be tied to business logic.  Including your custom tag into your library requires using the <code class="literal">handler-class</code> element.
			</p><pre class="programlisting">&lt;tag&gt;
  &lt;tag-name&gt;if&lt;/tag-name&gt;
  &lt;handler-class&gt;com.mycompany.IfHandler&lt;/handler-class&gt;
&lt;/tag&gt;</pre><p>
				All tags in a Facelets extend <code class="literal">com.sun.facelets.tag.TagHandler</code> which provides some base functionality for tying XML data to your Java code.  To read more about creating custom tags, jump to <a href="#dev-taghandler" title="7.2. Custom TagHandlers">Section 7.2, “Custom TagHandlers”</a>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="taglib-create-function" />3.5.7. Function Specification</h3></div></div><div /></div><p>
				You may reference functions within your tag library.  Functions are represented by static methods in Java.
			</p><pre class="programlisting">&lt;function&gt;
  &lt;function-name&gt;reverse&lt;/function-name&gt;
  &lt;function-class&gt;com.mycompany.Functions&lt;/function-class&gt;
  &lt;function-signature&gt;java.lang.String reverse(java.lang.String)&lt;/function-signature&gt;
&lt;/function&gt;</pre><p>
				The <code class="literal">function</code> element is a top level entity like the <code class="literal">tag</code> element.  You need to specify both the class type and the method signature that Facelets should use.  All class names in the signature must be fully qualified, with the exception of primitives such as <code class="literal">int</code> or <code class="literal">boolean</code>.
			</p><p>
				In this example, you would be able to reference this function with a namespace prefix in your document, such as <code class="literal">#{my:reverse{employee.name}}</code>.  See <a href="#taglib-function" title="3.3. Functions">Section 3.3, “Functions”</a> for more information on function use in your pages.
			</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="el" />Chapter 4. Expression Language</h2></div></div><div /></div><div class="preface" lang="en"><div class="titlepage"><div /><div /></div><p>
			Facelets utilizes the new EL Specification and will continue to support it in future revisions.  This may include extra language extensions such as method invocation and inlined sets, for example.
		</p><p>
			With the new EL Specification, the use of <code class="literal">#{...}</code> and <code class="literal">${...}</code> are both supported and Facelets makes no distinction between the two.  The short of it is that you can freely interchange the two with whatever is most familiar to what you're working on.  Both syntaxes will be handled the same way and share the same lifecycles and features.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="el-inline" />4.1. Inlining Text</h2></div></div><div /></div><p>
			Text and expressions can exist anywhere in the document.  This means you can have an example like below, and have Facelets correctly evaluate it at render time.
		</p><pre class="programlisting">&lt;span&gt;Your Basket has ${basket.lineCount} Items&lt;/span&gt;</pre></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="el-lifecycle" />4.2. EL Lifecycle</h2></div></div><div /></div><p>
			Facelets provides a unique lifecycle to EL.  When building a <code class="literal">UIComponent</code> tree, all EL expressions are re-built based on the state of the current <code class="literal">FaceletContext</code>.  These expressions are either stored on things like <code class="literal">UIComponents</code> or stored in the component tree as text.  When it's time to render, then these expressions are evaluated as the second phase.  This offers the truest form of variable/state management in relation to tree building within JavaServer Faces.  This is also a feature that is not supported within JSP for inlined text.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="template" />Chapter 5. Templating and Re-Use</h2></div></div><div /></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="template-overview" />Overview</h2></div></div><div /></div><p>
			When I set out to design the Facelets framework, my main emphasis was ease of integration with JavaServer Faces.  A ways into the the notebook of ideas, I saw that templating and re-use would have to be just as important within your documents, if not more important than the JSF integration features.  Thusly, the Facelet compiler makes special accomodations to the built-in UI tag library for high-perforance templating in your pages.  This section acts as both an introduction and a whiteboard for ideas you may pursue with Facelets and JavaServer Faces.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-detail" />5.1. Template/Client Relationships</h2></div></div><div /></div><p>
        		When describing templating within Facelets, we have two roles: the template and the template client.
        	</p><p>
        		Any document can act as a template; but what makes a document a template?  It just simply uses one or more <code class="literal">&lt;ui:insert/&gt;</code> tags to inject content from another source.
        	</p><p>
        		The other half of the equation is the template client.  This includes documents that use the <code class="literal">&lt;ui:component/&gt;</code>, <code class="literal">&lt;ui:composition/&gt;</code>, <code class="literal">&lt;ui:fragment/&gt;</code>, or <code class="literal">&lt;ui:decorate/&gt;</code>.  Each of those tags is detailed in the sections below.
        	</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="template-detail-wrap" />5.1.1. Wrapping Content within a Template</h3></div></div><div /></div><p>
					A template client can refrain from using <code class="literal">&lt;ui:define&gt;</code> tags in their body; then the target template only uses a single <code class="literal">&lt;ui:insert/&gt;</code> (without the <code class="literal">name</code> attribute).  This will cause the body of the template client to be injected into the template wherever the 'nameless' <code class="literal">&lt;ui:insert/&gt;</code> is located.
				</p><pre class="programlisting">&lt;!-- template document --&gt;
...
&lt;span class="repeatingBox"&gt;
  &lt;c:forEach begin="1" end="10"&gt;
    &lt;ui:insert/&gt;&lt;br/&gt;
  &lt;/c:forEach&gt;
&lt;/span&gt;
...</pre><pre class="programlisting">&lt;!-- template client document --&gt;
...
&lt;ui:composition template="template.xhtml"&gt;
  I'm in the spin cycle &lt;h:outputText value="#{random.name}"/&gt;!
&lt;/ui:composition&gt;
...</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="template-detail-piecemeal" />5.1.2. Piecemeal Content within a Template</h3></div></div><div /></div><p>
					A template client can break up its body within multiple, named <code class="literal">&lt;ui:define&gt;</code> tags.  These tags may specify what goes in the menu, in the header, and within the content area all at once.  See <a href="#gettingstarted-view" title="1.6. Creating Web Pages">Section 1.6, “Creating Web Pages”</a> for a good example of this type of templating.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="template-detail-deep" />5.1.3. Multi-Level Templating</h3></div></div><div /></div><p>
					Template use may go multiple levels deep.  This means that a template client may use a template which in turn may use a template, which may also use a template, and then it may use yet another template... you get the picture.
				</p><p>
					Templating is backed by the a <code class="literal">TemplateManager</code> that has a stack of <code class="literal">TemplateClient</code> instances.  Tags like <code class="literal">&lt;ui:composition&gt;</code> implement <code class="literal">TemplateClient</code>.  When a template is being evaluated and comes upon a <code class="literal">&lt;ui:insert/&gt;</code> tag, it will ask the <code class="literal">TemplateManager</code> for a <code class="literal">TemplateClient</code> that either has a match for the tag's name attribute, or the top-most <code class="literal">TemplateClient</code> on the stack.
				</p><p>
					An example would be having a <code class="literal">&lt;ui:insert name="title"/&gt;</code> tag in the template.  The <code class="literal">TemplateManager</code> will walk through its internal stack of <code class="literal">TemplateClients</code>, asking each one for a content under the name <code class="literal">title</code>.  It will continue through the stack until one is found.  If none are found, then the original template is free to include the default content.  See <a href="#template-insert" title="5.9. &lt;ui:insert/&gt;">Section 5.9, “&lt;ui:insert/&gt;”</a> for more information on default content.
				</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-component" />5.2. &lt;ui:component/&gt;</h2></div></div><div /></div><div class="table"><a id="N10816" /><p class="title"><b>Table 5.1. Component Tag Attributes</b></p><table xmlns="" summary="Component Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>id</td><td>false</td><td>A unique id may be provided, otherwise Facelets will automatically assign one under the same logic it uses for all <code class="literal">UIComponents</code>.</td><td xmlns="">mainMenu</td></tr><tr><td>binding</td><td>false</td><td>This binding attribute is used the same as with any other <code class="literal">UIComponent</code> such that it allows you to reference them as a property of a JavaBean.  If that target property did not have a <code xmlns="" class="literal">UIComponent</code> instance assigned already, JavaServer Faces will lazily create an instance for you and set it on your JavaBean before continuing with building the tree.</td><td xmlns="">#{page.menu}</td></tr></tbody></table></div><p>
			The <code class="literal">component</code> tag and the <code class="literal">composition</code> tag (below) behave exactly the same, except the <code class="literal">component</code> tag will insert a new <code class="literal">UIComponent</code> instance into the tree as the root of all the child components/fragments it has.
		</p><pre class="programlisting">Text before will be removed.
&lt;ui:component binding="#{backingBean.menu}"&gt;
  &lt;ul id="mainMenu"&gt;
  &lt;c:forEach var="link" items="#{menuOptions[role]}"&gt;
	&lt;c:choose&gt;
	  &lt;c:when test="#{link.id == page}"&gt;
		&lt;li class="current"&gt;&lt;a href="#{link.uri}"&gt;#{link.text}&lt;/a&gt;&lt;/li&gt;
	  &lt;/c:when&gt;
	  &lt;c:otherwise&gt;
		&lt;li&gt;&lt;a href="#{link.uri}"&gt;#{link.text}&lt;/a&gt;&lt;/li&gt;
	  &lt;/c:otherwise&gt;
	&lt;/c:choose&gt;
  &lt;/c:forEach&gt;
  &lt;/ul&gt;
&lt;/ui:component&gt;
Text after will be removed.</pre><p>
			Using the ability to use Tag files in your tag libraries, see <a href="#taglib-create-source" title="3.5.5. Tag (Source) Files">Section 3.5.5, “Tag (Source) Files”</a>, you could include the above <code class="literal">component</code> into your pages while having the attributes automatically made available as variables within the document above:
		</p><pre class="programlisting">...
&lt;span id="header"&gt;
  &lt;my:mainMenu page="home" role="#{user.role}"/&gt;
&lt;/span&gt;
...</pre><p>
			Pretty cool eh?
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-composition" />5.3. &lt;ui:composition/&gt;</h2></div></div><div /></div><div class="table"><a id="N1086B" /><p class="title"><b>Table 5.2. Composition Tag Attributes</b></p><table xmlns="" summary="Composition Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>template</td><td>false</td><td>The resolvable URI of the template to use.  The content within the <code class="literal">composition</code> tag will be used in populating the template specified.</td><td xmlns="">/WEB-INF/templates/detal-template.xhtml</td></tr></tbody></table></div><p>
			Facelets is founded on the idea of compositions. This means that a <code class="literal">UIComponent</code> tree can be defined in multiple Facelet pages and executed in part or whole. Some other frameworks, like Tapestry (http://jakarta.apache.org/tapestry), may define a single component within a page, Facelets instead marks the start of a branch of child <code class="literal">UIComponents</code>-- a composition if you will.
		</p><pre class="programlisting">Text before will be removed.
&lt;ui:composition&gt;
  #{dynamic.text}
  &lt;h:inputText id="myText" value="#{foo.bar}"/&gt;
&lt;/ui:composition&gt;
Text after will be removed.</pre><p>
			This means you can start a full XHTML document in your favorite visual tool with CSS definitions, but have Facelets trim everything outside of the <code class="literal">&lt;ui:composition/&gt;</code> tag.  Here's a simple example of using a composition in separate document:
		</p><pre class="programlisting">...
&lt;h:column&gt;
  &lt;ui:include src="/composition.xhtml"/&gt;
&lt;/h:column&gt;
...</pre><p>
			Lets say this composition was included inside of a <code class="literal">&lt;h:column/&gt;</code> tag/component; it would gain two children based on the above example: <code class="literal">#{dynamic.text}</code> and the <code class="literal">&lt;h:inputText/&gt;</code>.
		</p><p>
			The composition tag has templating abilities, to read more about how templating is coordinated, jump over to <a href="#template-define" title="5.6. &lt;ui:define/&gt;">Section 5.6, “&lt;ui:define/&gt;”</a> and <a href="#template-insert" title="5.9. &lt;ui:insert/&gt;">Section 5.9, “&lt;ui:insert/&gt;”</a>.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-debug" />5.4. &lt;ui:debug/&gt;</h2></div></div><div /></div><div class="table"><a id="N108B8" /><p class="title"><b>Table 5.3. Debug Tag Attributes</b></p><table xmlns="" summary="Debug Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>hotkey</td><td>false</td><td>The hot key to use in combination with 'CTRL' + 'SHIFT' to launch the debug window.  By default, when the <code class="literal">debug</code> tag is used, you may launch the debug window with 'CTRL' + 'SHIFT' + 'D'.  This value cannot be an EL expression.</td><td xmlns="">d</td></tr></tbody></table></div><p>
			The <code class="literal">debug</code> tag will capture the component tree and variables when it is encoded, storing the data for retrieval later.  You may launch the debug window at any time from your browser by pressing 'CTRL' + 'SHIFT' + 'D' (by default).
		</p><pre class="programlisting">...
  &lt;ui:debug hotkey="d" rendered="#{initParam.debugMode}"/&gt;
 &lt;/body&gt;
&lt;/html&gt;
...</pre><p>
			In the above example, we use the hot key 'd' to launch the debug window.  Creating debug output on every request adds some overhead, so you can use the <code class="literal">UIComponent</code> <code class="literal">rendered</code> property to turn debugging on or off based on some expression.  In this example, debugging is backed by an entry in the <code class="literal">web.xml</code>.
		</p><p>
			The <code class="literal">debug</code> tag doesn't need to be used with the <code class="literal">facelet.DEVELOPMENT</code> parameter.  The best place to put this tag is in your site's main template where it can be enabled/disabled across your whole application.  If your application uses multiple windows, you might want to assign different hot keys to each one.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="templating-decorate" />5.5. &lt;ui:decorate/&gt;</h2></div></div><div /></div><div class="table"><a id="N108FA" /><p class="title"><b>Table 5.4. Decorate Tag Attributes</b></p><table xmlns="" summary="Decorate Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>template</td><td>true</td><td>The resolvable URI of the template to use.  The content within the <code class="literal">decorate</code> tag will be used in populating the template specified.</td><td xmlns="">/WEB-INF/templates/sideBox.xhtml</td></tr></tbody></table></div><p>
			The <code class="literal">decorate</code> tag acts the same as a <code class="literal">composition</code> tag, but it will not trim everything outside of it.  This is useful in cases where you have a list of items in a document, which you would like to be decorated or framed.  The sum of it all is that you can take any element in the document and decorate it with some external logic as provided by the <code class="literal">template</code>.
		</p><pre class="programlisting">Text before will stay.
&lt;ui:decorate template="/WEB-INF/templates/sideBox.xhtml"&gt;
  &lt;ui:define name="title"&gt;Product Search&lt;/ui:define&gt;
  &lt;ui:define name="body"&gt;
    ...
  &lt;/ui:define&gt;
&lt;/ui:decorate&gt;
Text after will stay.</pre><p>
			In some cases, it would make sense to externalize your "Product Search" box into a separate file, in other cases it doesn't and the <code class="literal">decorate</code> tag allows you to inline as such.
		</p><p>
			For more information on how templating works in relation to the <code class="literal">&lt;ui:define/&gt;</code> tags, see <a href="#template-define" title="5.6. &lt;ui:define/&gt;">Section 5.6, “&lt;ui:define/&gt;”</a>.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-define" />5.6. &lt;ui:define/&gt;</h2></div></div><div /></div><div class="table"><a id="N1093B" /><p class="title"><b>Table 5.5. Define Tag Attributes</b></p><table xmlns="" summary="Define Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>name</td><td>true</td><td>The literal name for this definition.  This name will match up with a <code class="literal">&lt;ui:insert/&gt;</code> tag in a target template.</td><td xmlns="">header</td></tr></tbody></table></div><p>
			The <code class="literal">define</code> tag can be used within tags that allow templating.  This includes <code class="literal">composition</code> and <code class="literal">decorate</code> tags.
		</p><pre class="programlisting">Text before will stay.
&lt;ui:decorate template="/WEB-INF/templates/sideBox.xhtml"&gt;
  &lt;ui:define name="title"&gt;Product Search&lt;/ui:define&gt;
  &lt;ui:define name="body"&gt;
    ...
  &lt;/ui:define&gt;
&lt;/ui:decorate&gt;
Text after will stay.</pre><p>
			The use of this tag will be familiar to those that have used Struts Tiles, for example.  The <code class="literal">define</code> tag is used in conjuction with the target template's <code class="literal">insert</code> tag, which you can read more about in <a href="#template-insert" title="5.9. &lt;ui:insert/&gt;">Section 5.9, “&lt;ui:insert/&gt;”</a>.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-fragment" />5.7. &lt;ui:fragment/&gt;</h2></div></div><div /></div><div class="table"><a id="N1097A" /><p class="title"><b>Table 5.6. Fragment Tag Attributes</b></p><table xmlns="" summary="Fragment Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>id</td><td>false</td><td>A unique id may be provided, otherwise Facelets will automatically assign one under the same logic it uses for all <code class="literal">UIComponents</code>.</td><td xmlns="">mainMenu</td></tr><tr><td>binding</td><td>false</td><td>This binding attribute is used the same as with any other <code class="literal">UIComponent</code> such that it allows you to reference them as a property of a JavaBean.  If that target property did not have a <code xmlns="" class="literal">UIComponent</code> instance assigned already, JavaServer Faces will lazily create an instance for you and set it on your JavaBean before continuing with building the tree.</td><td xmlns="">#{uiCache['searchResults']}</td></tr></tbody></table></div><p>
			Just like <code class="literal">composition</code> has <code class="literal">decorate</code> as a non-trimming version of the same behavior, <code class="literal">component</code> has <code class="literal">fragment</code>.  This allows you to logically insert a <code class="literal">UIComponent</code> into the tree and possibly bind this fragment to a JavaBean property or Map for management.
		</p><pre class="programlisting">The Text above will be used.
&lt;ui:fragment binding="#{uiCache['searchResult']}"&gt;
  &lt;div id="searchResults"&gt;
	...
  &lt;/div&gt;
&lt;/ui:fragment&gt;
The Text below will be used.</pre><p>
			The <code class="literal">fragment</code> tag was also added to Facelets to get around some of the optimizations used in handling text within your document.  If you are using components such as <code class="literal">&lt;f:panelGrid/&gt;</code>, which renders its children, you may want more control over the building process that Facelets does and using a <code class="literal">fragment</code> tag will help guarantee parent/child relationships for you.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-include" />5.8. &lt;ui:include/&gt;</h2></div></div><div /></div><div class="table"><a id="N109D3" /><p class="title"><b>Table 5.7. Include Tag Attributes</b></p><table xmlns="" summary="Include Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>src</td><td>true</td><td>A literal or EL expression that specifies the target Facelet that you would like to include into your document.</td><td>anotherPage.xhtml</td></tr></tbody></table></div><p>
			This tag should be familiar to most.  The <code class="literal">include</code> tag can point at any Facelet which might use the <code class="literal">composition</code> tag, <code class="literal">component</code> tag, or simply be straight XHTML/XML. 
		</p><p>
			It should be noted that the <code class="literal">src</code> path does allow relative path names, but they will always be resolved against the original Facelet requested.
		</p><pre class="programlisting">&lt;span id="header"&gt;
  &lt;ui:include src="#{backingBean.headerSource}"/&gt;
&lt;/span&gt;</pre><p>
			The <code class="literal">include</code> tag can be used in conjunction with multiple <code class="literal">&lt;ui:param/&gt;</code> tags to pass EL expressions/values to the target page. See <a href="#template-param" title="5.10. &lt;ui:param/&gt;">Section 5.10, “&lt;ui:param/&gt;”</a>, for more on passing variables to other pages.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-insert" />5.9. &lt;ui:insert/&gt;</h2></div></div><div /></div><div class="table"><a id="N10A14" /><p class="title"><b>Table 5.8. Insert Tag Attributes</b></p><table xmlns="" summary="Insert Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>name</td><td>false</td><td>The optional name attribute matches the associated <code class="literal">&lt;ui:define/&gt;</code> tag in this template's client.  If no name is specified, it's expected that the whole template client will be inserted.</td><td xmlns="">header</td></tr></tbody></table></div><p>
			The <code class="literal">insert</code> tag is used within your templates to declare spots of replaceable data.
		</p><pre class="programlisting">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /&gt;
&lt;title&gt;&lt;ui:insert name="title"&gt;Default Title&lt;/ui:insert&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Here is the Page Header&lt;/h1&gt;
&lt;ui:insert name="body"&gt;
  Default Body
&lt;/ui:insert&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>
			As you can see, these <code class="literal">insert</code> tags indicate to the Facelets compiler where to insert content from the template client.  If the template client doesn't specify content for the specified name, then the body of the ui:insert tag in the template is used.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-param" />5.10. &lt;ui:param/&gt;</h2></div></div><div /></div><div class="table"><a id="N10A44" /><p class="title"><b>Table 5.9. Param Tag Attributes</b></p><table xmlns="" summary="Param Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>name</td><td>true</td><td>The name of the variable to pass to the included Facelet.</td><td>user</td></tr><tr><td>value</td><td>true</td><td>The literal or EL expression value to assign to the named variable.</td><td>#{sessionScope.user}</td></tr></tbody></table></div><p>
			From reading about Facelets templating, you've probably become familiar with passing fragments of content between pages.  With the <code class="literal">param</code> tag, you can pass objects as variables instead of just fragments of content.  You can use the <code class="literal">param</code> tag wherever a <code class="literal">define</code> tag is used within <code class="literal">composition</code> or <code class="literal">decorate</code> tags, in addition to passing objects to an <code class="literal">include</code> tag.
		</p><pre class="programlisting">&lt;span id="leftNav"&gt;
  &lt;ui:include src="/WEB-INF/siteNav.xhtml"&gt;
    &lt;ui:param name="user" value="#{currentUser}"/&gt;
    &lt;ui:param name="page" value="home"/&gt;
  &lt;/ui:include&gt;
&lt;/span&gt;</pre><p>
			In the above example, when <code class="literal">siteNav.xhtml</code> is used, it will have <code class="literal">user</code> and <code class="literal">page</code> variables available for use which will reference the the <code class="literal">currentUser</code> object and the <code class="literal">home</code> string literal.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-remove" />5.11. &lt;ui:remove/&gt;</h2></div></div><div /></div><p>
			The <code class="literal">remove</code> tag does not have any attributes and is used to remove chunks of XML content from a Facelet at compilation time.  The <code class="literal">remove</code> tag is often used in conjunction with the <code class="literal">jsfc</code> feature, see <a href="#taglib-use-jsfc" title="3.1.2. Using 'jsfc'">Section 3.1.2, “Using 'jsfc'”</a>. 
		</p><pre class="programlisting">...
&lt;ui:remove&gt;
  This will be removed.
&lt;/ui:remove&gt;
...
&lt;span jsfc="ui:remove"&gt;
	This won't be compiled either &lt;h:outputText value="#{foo.bar}"/&gt;
&lt;/span&gt;
...</pre><p>
			There are times in development when you need to quickly remove parts of the document just for testing purposes, or you would like to leave a 'template-model' in your document, but don't want it to be part of the final Facelet.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="template-repeat" />5.12. &lt;ui:repeat/&gt;</h2></div></div><div /></div><div class="table"><a id="N10AB7" /><p class="title"><b>Table 5.10. Repeat Tag Attributes</b></p><table xmlns="" summary="Repeat Tag Attributes" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>value</td><td>true</td><td>Expression for the List of items to iterate over</td><td>#{blog.currentEntries}</td></tr><tr><td>var</td><td>true</td><td>The literal name of the variable to use while iterating</td><td>entry</td></tr></tbody></table></div><p>
			The <code class="literal">repeat</code> tag should be used in almost all cases instead of the <code class="literal">c:forEach</code> to iterate over content with JSF.  The <code class="literal">repeat</code> tag is often used in conjunction with the <code class="literal">jsfc</code> feature, see <a href="#taglib-use-jsfc" title="3.1.2. Using 'jsfc'">Section 3.1.2, “Using 'jsfc'”</a>. 
		</p><pre class="programlisting">...
&lt;dl&gt;
    &lt;ui:repeat value="#{company.departments}" var="dept"&gt;
    &lt;dt&gt;#{dept.name}&lt;/dt&gt;
	    &lt;ui:repeat value="#{dept.employees}" var="emp"&gt;
		&lt;dd&gt;#{emp.lastName}, #{emp.firstName}&lt;/dd&gt;
		&lt;/ui:repeat&gt;
    &lt;/ui:repeat&gt;
&lt;/dl&gt;
...</pre><p>
			While this is a great step for JSF compositions, we can do better with the <code class="literal">jsfc</code> attribute where the <code class="literal">repeat</code> tag will provide some special behavior inclusive of the declared tag.
		</p><pre class="programlisting">...
&lt;table&gt;
&lt;tr jsfc="ui:repeat" value="#{dept.employees}" var="emp" class="#{emp.manager ? 'mngr' : 'peon'}"&gt;
   &lt;td&gt;#{emp.lastName}&lt;/td&gt;&lt;td&gt;#{emp.firstName}&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
...</pre></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="architecture" />Chapter 6. Facelets Architecture</h2></div></div><div /></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="architecture-views" />6.1. View Creation</h2></div></div><div /></div><p>
			Under the JavaServer Faces specification, there are some preliminary steps that must be covered when building views.  This section will cover that process and its lifecycle in relation to Facelets.
		</p><div class="orderedlist"><ol type="1"><li><p>A request comes in to JavaServer Faces for a new view (or page).  The <code class="literal">FaceletViewHandler</code> simply creates a new <code class="literal">UIViewRoot</code> for this new view.</p></li><li><p>Since this is a new view being requested, we immediately render our view.  Before rendering, Facelets needs to populate the view with components.  At this time, the <code class="literal">FaceletFactory</code> is used to build a <code class="literal">Facelet</code> that will act as build instructions for the desired view. The <code class="literal">UIViewRoot</code> is applied to the <code class="literal">Facelet</code> and the view is populated for rendering.</p></li><li><p>The <code class="literal">UIViewRoot</code> (view) is then asked to render itself back to the response.</p></li><li><p>The user sees a completed web page and the state of the view is automatically stored for the next request.  Note, all the inlined text and other transient components will not be stored, only 'crucial' component information such as input components and form data.</p></li><li><p>The user clicks a button, causing a second request to come back to JavaServer Faces.  This time, the view is restored from the previously stored state.  Keep in mind, the view at this point only has the 'crucial' components available from the previous request.</p></li><li><p>This restored view is passed through the JavaServer Faces lifecycle and eventually we will either generate a new view for another page, or re-render your current view if there were validation problems or no action was fired.</p></li><li><p>In the case of re-rendering the view, the partial view that was restored is now rendered again.  Before it's rendered, the same <code class="literal">Facelet</code> is used to re-populate the full view with inlined text and transient components.</p></li><li><p>The <code class="literal">UIViewRoot</code> (view) is then asked to render itself back to the response.</p></li><li><p>Repeat this process until another (new) view is requested.</p></li></ol></div><p>
			The first take-away from those steps is that the same <code class="literal">Facelet</code> can be used multiple times with the same view.  Basically, the process of building the view (a.k.a component tree) can go through many cycles of populating, rendering, trimming for state saving, then restored again-- repeat.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="architecture-api" />6.2. Facelets API</h2></div></div><div /></div><p>
			Facelets is founded on simple principles and the API is a solid reflection of it.  The framework is focused on one specific task, and that's tree creation and content interweaving-- taking an XHTML or XML document and using it as instructions to populate a tree of <code class="literal">UIComponents</code>.  That's it.
		</p><p>
			The JavaServer Faces platform is extremely extensible on many levels and Facelets only provides one part of that equation.  Different render kits, controllers, components, validators, converters, frameworks-- all usable with Facelets.  That's the beauty of JavaServer Faces as a platform that Facelets only seeks to enhance.
		</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-api-factory" />6.2.1. FaceletFactory</h3></div></div><div /></div><p>
				The <code class="literal">FaceletFactory</code> is an interface to the Facelet compiler while offering features such as caching and modification monitoring. 
			</p><pre class="programlisting">FaceletFactory factory = FaceletFactory.getInstance();
Facelet facelet = factory.getFacelet("/example.xml");</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-api-facelet" />6.2.2. Facelet</h3></div></div><div /></div><p>
				The <code class="literal">Facelet</code> class is similar to a lot of the Servlet API, such that it's stateless and can handle multiple threads accessing it at once.  The Facelet's soul responsibility is to populate a tree of <code class="literal">UIComponents</code> for manipulation and, of course, rendering.  A single instance is representative of physical XML resource, compiled into memory once and shared for all requests.
			</p><pre class="programlisting">FacesContext faces = FacesContext.getCurrentInstance();
Facelet facelet = factory.getFacelet("/example.xml");
facelet.apply(faces, faces.getViewRoot());
</pre><p>
				After 'applying' this <code class="literal">Facelet</code> to the <code class="literal">UIViewRoot</code>, it will be fully populated according to your various XHTML or XML pages used with the Facelets framework.
			</p><p>
				<code class="literal">Facelets</code> delegate tree creation logic to an internal tree of <code class="literal">FaceletHandlers</code> constructed by the compiler.  The action of passing <code class="literal">UIComponents</code> through the tree of <code class="literal">FaceletHandlers</code> causes the view to be populated in a <code class="literal">UIComponent</code> tree, reflective of the logic included in the <code class="literal">FaceletHandlers</code>.
			</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="architecture-api-handler" />6.2.3. FaceletHandler</h3></div></div><div /></div><p>
				The <code class="literal">FaceletHandler</code> is a part of a parent <code class="literal">Facelet</code> in a many to one association.  <code class="literal">FaceletHandlers</code> work off of the visitor pattern where state is passed to them for modification and tree creation, then possibly passed along to the next <code class="literal">FaceletHandler</code> in the chain.  
			</p><pre class="programlisting">public class LoggingHandler implements FaceletHandler
  public void apply(FaceletContext ctx, UIComponent parent)
            throws IOException, FacesException, FaceletException, ELException {
    Logger.getLogger("example").info("Hello Logger");
  }
}</pre><p>
				That example, while silly, shows the simple API that the FaceletHandler uses.  If you would like to construct your own FaceletHandlers for use in <code class="literal">UIComponent</code> tree creation, jump over to <a href="#dev-taghandler" title="7.2. Custom TagHandlers">Section 7.2, “Custom TagHandlers”</a>.
			</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="architecture-compiler" />6.3. Document Compiler</h2></div></div><div /></div><p>
			It's a secret.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="dev" />Chapter 7. Extending Facelets</h2></div></div><div /></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="dev-tag" />7.1. Tag Development Overview</h2></div></div><div /></div><p>
			Facelets use stateless <code class="literal">TagHandlers</code> to coordinate tree creation.  <code class="literal">TagHandlers</code> are not like JSP tags in that Facelets builds a static/stateless tree of <code class="literal">TagHandlers</code> shared by all requests.  For more information on how Facelets coordinates view creation, see <a href="#architecture-views" title="6.1. View Creation">Section 6.1, “View Creation”</a>.
		</p><p>
			Foundation classes, such as those included in <a href="#dev-meta" title="7.3. Meta Tags">Section 7.3, “Meta Tags”</a>, will take care of the knowing when to apply state and build up the component tree for a given request.  If you are writing your own <code class="literal">TagHandler</code>, you can use the <code class="literal">ComponentSupport.isNew(UIComponent)</code> to determine if it's okay for you to modify the newly created <code class="literal">UIComponent</code>.
		</p><pre class="programlisting">public void apply(FaceletContext ctx, UIComponent parent) {
  if (ComponentSupport.isNew(parent)) {
    // okay to apply new state information to component
  }
}</pre><p>
			For JSTL-like functionality, it's up to you if you want to use the <code class="literal">ComponentSupport.isNew(UIComponent)</code> method to determine behavior.  But again, if you use the foundation handlers in <a href="#dev-meta" title="7.3. Meta Tags">Section 7.3, “Meta Tags”</a>, these checks will be take care of for you.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="dev-taghandler" />7.2. Custom TagHandlers</h2></div></div><div /></div><p>
			Facelets are composed of many different kinds of <code class="literal">TagHandler</code> instances.  Just like a <code class="literal">Facelet</code>, all of the <code class="literal">TagHandlers</code> are stateless for offering a higher degree of performance.  This section goes over customizing your tag library with your own tags, beyond what the default features of Facelets can offer you within the tag library XML configs.
		</p><p>
			Facelets allows you to write stateless tags that can be used in dictating component tree creation.  This includes JSTL-like functionality that may be tied to business logic.  Including your custom tag into your library requires using the <code class="literal">handler-class</code> element.
		</p><pre class="programlisting">&lt;tag&gt;
  &lt;tag-name&gt;if&lt;/tag-name&gt;
  &lt;handler-class&gt;com.mycompany.IfHandler&lt;/handler-class&gt;
&lt;/tag&gt;</pre><p>
				All tags in a Facelets extend <code class="literal">com.sun.facelets.tag.TagHandler</code> which provides some base functionality for tying XML data to your Java code.  Here is an example of JSTL's <code class="literal">&lt;c:if/&gt;</code> tag:
			</p><pre class="programlisting">public final class IfHandler extends TagHandler {

  // possible attributes
  private final TagAttribute test;
  private final TagAttribute var;

  /**
   * @param config
   */
  public IfHandler(TagConfig config) {
      super(config);
      
      // helper method for getting a required attribute
      this.test = this.getRequiredAttribute("test");
      
      // helper method
      this.var = this.getAttribute("var");
  }

  /**
   * Threadsafe Method for controlling evaluation of
   * its child tags, represented by "nextHandler"
   */
  public void apply(FaceletContext ctx, UIComponent parent)
          throws IOException, FacesException, ELException {
      boolean b = this.test.getBoolean(ctx);
      if (this.var != null) {
          ctx.setAttribute(var.getValue(ctx), new Boolean(b));
      }
      if (b) {
          this.nextHandler.apply(ctx, parent);
      }
  }
}</pre><p>
			Now if that isn't easy, I don't know what is.  Facelets uses the concept of a <code class="literal">TagAttribute</code> which encapsulates EL operations for you and also produces informative exceptions if an error did occur.  Another really great example is catching exceptions with JSTL's <code class="literal">CatchHandler</code>:
		</p><pre class="programlisting">public final class CatchHandler extends TagHandler {

  private final TagAttribute var;

  public CatchHandler(TagConfig config) {
      super(config);
      this.var = this.getAttribute("var");
  }

  public void apply(FaceletContext ctx, UIComponent parent)
          throws IOException, FacesException, FaceletException, ELException {
      try {
          this.nextHandler.apply(ctx, parent);
      } catch (Exception e) {
          if (this.var != null) {
              ctx.setAttribute(this.var.getValue(ctx), e);
          }
      }
  }
}</pre><p>
			Isn't that awesome? The <code class="literal">TagHandler</code> provides some member variables, much like a JSP tag, to help you:
		</p><div class="table"><a id="N10C37" /><p class="title"><b>Table 7.1. TagHandler Member Variables</b></p><table xmlns="" summary="TagHandler Member Variables" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Variable Name</th><th>Class Type</th><th>Description</th></tr></thead><tbody><tr><td>tagId</td><td>java.lang.String</td><td>A unique id, assigned at compilation time for this stateless element.  This can be used in combination with the <code class="literal">FaceletContext.generateUniqueId(String)</code> to generate consistently unique ids for a given page evaluation.</td></tr><tr xmlns=""><td>tag</td><td>com.sun.facelets.tag.Tag</td><td>A <code class="literal">Tag</code> instance which is Facelet's representation of the element declared in a page.  The <code xmlns="" class="literal">Tag</code> includes namespace/name information, along with accessors to the <code xmlns="" class="literal">TagAttributes</code> specified on the element declared in the page.</td></tr><tr xmlns=""><td>nextHandler</td><td>com.sun.facelets.FaceletHandler</td><td>A generic interface representing zero or more child tags and their associated handlers.  Since Facelets uses stateless <code class="literal">TagHandlers</code>, the parent handler can evaluate the <code xmlns="" class="literal">nextHandler</code> any number of times or not at all to dictate component tree creation.</td></tr></tbody></table></div><p xmlns="">
			For more information on the inner workings of Facelets, please hop over to <a href="#architecture" title="Chapter 6. Facelets Architecture">Chapter 6, <i>Facelets Architecture</i></a>.
		</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="dev-meta" />7.3. Meta Tags</h2></div></div><div /></div><p>
				The Facelets API understands that developers will run into cases where they need 'special' logic for setting attributes.  The API provides a few foundation <code class="literal">TagHandlers</code> that you can extend to handle unique cases.  These foundation classes take care of the dirty work of tree creation in JavaServer Faces.
			</p><p>
				<code class="literal">com.sun.facelets.tag.MetaTagHandler</code> acts as the foundation for auto-wiring abilities in Facelets.  The <code class="literal">MetaTagHandler</code> uses a few objects: <code class="literal">MetaRuleset</code>, <code class="literal">MetaRule</code>, and <code class="literal">Metadata</code> to coordinate auto-wiring.  The following sub sections provide examples of this coordination to customize specialized components.
			</p><p>
				The <code class="literal">MetaTagHandler</code> provides a couple methods for extension: <code class="literal">setAttributes(FaceletContext,Object)</code> and <code class="literal">createMetaRuleset(Class)</code>.  The method <code class="literal">setAttributes(FaceletContext,Object)</code> will be invoked for you by the classes described below which will take care of wiring all attributes according to the <code class="literal">MetaRuleset</code> created by <code class="literal">createMetaRuleset(Class)</code>.
			</p><p>
				Anytime you do provide custom tags (handlers), you would use the <code class="literal">handler-class</code> element in your <code class="literal">tag</code> just as described in <a href="#taglib-create-custom" title="3.5.6. Custom Tags">Section 3.5.6, “Custom Tags”</a>.
			</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="dev-meta-component" />7.3.1. Custom ComponentHandlers</h3></div></div><div /></div><p>
					Component wiring can be customized by extending the <code class="literal">com.sun.facelets.tag.jsf.ComponentHandler</code> class.
				</p><pre class="programlisting">public class HtmlComponentHandler extends ComponentHandler {

  /**
   * @param config
   */
  public HtmlComponentHandler(ComponentConfig config) {
      super(config);
  }

  protected MetaRuleset createMetaRuleset(Class type) {
      return super.createMetaRuleset(type).alias("class", "styleClass");
  }

}</pre><p>
					In this example, we override the <code class="literal">createMetaRuleset(Class)</code> to alias wiring <code class="literal">class</code> attributes to the <code class="literal">styleClass</code> JavaBean property.  To add your custom component to your tag library, do the following:
				</p><pre class="programlisting">...
&lt;tag&gt;
  &lt;tag-name&gt;custom&lt;/tag-name&gt;
  &lt;component&gt;
    &lt;component-type&gt;com.company.Component&lt;/component-type&gt;
    &lt;renderer-type&gt;com.company.OptionalRenderer&lt;/renderer-type&gt;
    &lt;handler-class&gt;com.company.HtmlComponentHandler&lt;/handler-class&gt;
  &lt;/component&gt;
&lt;/tag&gt;
...</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="dev-meta-validator" />7.3.2. Custom ValidateHandlers</h3></div></div><div /></div><p>
					In the previous example, Facelets will automatically wire <code class="literal">UIComponent</code> JavaBean properties and expressions to a given instance.  The bonus is that <code class="literal">MetaTagHandler</code> will set attributes on any instance of <code class="literal">Object</code>.  This opens the doors for working with things like <code class="literal">Validators</code> by extending <code class="literal">com.sun.facelets.tag.jsf.ValidateHandler</code>:
				</p><pre class="programlisting">public final class ValidateDelegateHandler extends ValidateHandler {

  private final TagAttribute validatorId;

  public ValidateDelegateHandler(TagConfig config) {
      super(config);
      this.validatorId = this.getRequiredAttribute("validatorId");
  }

  /**
   * Uses the specified "validatorId" to get a new Validator instance from the
   * Application.
   * 
   * @see javax.faces.application.Application#createValidator(java.lang.String)
   * @see com.sun.facelets.tag.jsf.ValidateHandler#createValidator(com.sun.facelets.FaceletContext)
   */
  protected Validator createValidator(FaceletContext ctx) {
      return ctx.getFacesContext().getApplication().createValidator(
              this.validatorId.getValue(ctx));
  }

  protected MetaRuleset createMetaRuleset(Class type) {
      return super.createMetaRuleset(type).ignoreAll();
  }
}</pre><p>
					In the above example, we've decided to do all of the attribute mapping ourselves, so we tell the <code class="literal">MetaRuleset</code> to <code class="literal">ignoreAll()</code>.
				</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="dev-meta-converter" />7.3.3. Custom ConvertHandlers</h3></div></div><div /></div><p>
					Continuing on the capabilities in customizing <code class="literal">Validators</code> within Facelets, you may do the same with <code class="literal">Converters</code> by extending <code class="literal">com.sun.facelets.tag.jsf.ConvertHandler</code>.
				</p><pre class="programlisting">public final class ConvertNumberHandler extends ConvertHandler {

    private final TagAttribute locale;

    public ConvertNumberHandler(TagConfig config) {
        super(config);
        this.locale = this.getAttribute("locale");
    }

    /**
     * Returns a new NumberConverter
     * 
     * @see NumberConverter
     * @see com.sun.facelets.tag.jsf.ConverterHandler#createConverter(com.sun.facelets.FaceletContext)
     */
    protected Converter createConverter(FaceletContext ctx)
            throws FacesException, ELException, FaceletException {
        return ctx.getFacesContext().getApplication().createConverter(NumberConverter.CONVERTER_ID);
    }

    /* (non-Javadoc)
     * @see com.sun.facelets.tag.ObjectHandler#setAttributes(com.sun.facelets.FaceletContext, java.lang.Object)
     */
    protected void setAttributes(FaceletContext ctx, Object obj) {
        super.setAttributes(ctx, obj);
        NumberConverter c = (NumberConverter) obj;
        if (this.locale != null) {
            c.setLocale(ComponentSupport.getLocale(ctx, this.locale));
        }
    }

    protected MetaRuleset createMetaRuleset(Class type) {
        return super.createMetaRuleset(type).ignore("locale");
    }
}</pre><p>
					This is probably the best example of customization so far.  The <code class="literal">ConvertHandler</code> allows you to override the method <code class="literal">createConverter(FaceletContext)</code> to return any <code class="literal">Converter</code> instance.  Also, the <code class="literal">setAttributes(FaceletContext,Object)</code> was overridden to do special wiring for the <code class="literal">Locale</code> on the <code class="literal">NumberConverter</code>.
				</p><p>
					The <code class="literal">NumberConverter</code> has many properties, but we only wanted to make a special case for <code class="literal">locale</code>, so we only tell the <code class="literal">MetaRuleset</code> to ignore that one attribute because we will take care of it ourselves.
				</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="dev-viewHandler" />7.4. FaceletViewHandler</h2></div></div><div /></div><p>
			Facelets comes with a <code class="literal">ViewHandler</code> that you may extend.  Some extension points include initializing the compiler and setting up alternate response writers for JavaServer Faces to use.
        </p><p>
			To learn more, look at the Facelets JavaDocs for the <code class="literal">com.sun.facelets.FaceletViewHandler</code>.
        </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="dev-tagdecorators" />7.5. Tag Decorators</h2></div></div><div /></div><p>
			The compiler within Facelets allows you to specify multiple <code class="literal">TagDecorator</code> instances.  These implementations can do things like transforming all HTML elements to their JSF equivalents automatically.
		</p><p>
			To add your custom <code class="literal">TagDecorator</code> to your Facelets project, you may extend the <code class="literal">FaceletViewHandler</code> and override the compiler initialization methods to add your <code class="literal">TagDecorator</code> to the passed <code class="literal">Compiler</code> instance.
		</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="building" />Chapter 8. Building Facelets</h2></div></div><div /></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="building-ant" />8.1. Using Ant</h2></div></div><div /></div><p>
			Facelets uses new features in 1.6.5, such as macros.
		</p><div class="table"><a id="N10D76" /><p class="title"><b>Table 8.1. Ant Targets</b></p><table xmlns="" summary="Ant Targets" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>compile</td><td>Just compiles the Facelets code base, requires JSF 1.2 API</td></tr><tr><td>javadoc</td><td>Generates JavaDocs for the API</td></tr><tr><td>doc</td><td>Generates this developer documentation</td></tr><tr><td>jar</td><td>Compiles, then Jars</td></tr><tr><td>dist</td><td>Does the jar'ing and prepares/populates the dist directory</td></tr><tr><td>clean</td><td>Cleans or resets the project</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="building-ide" />8.2. IDE Integration</h2></div></div><div /></div><div class="table"><a id="N10DA4" /><p class="title"><b>Table 8.2. Available IDEs</b></p><table xmlns="" summary="Available IDEs" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Name</th><th>Vendor</th><th>Link</th></tr></thead><tbody><tr><td>Exadel Studio</td><td>Exadel</td><td>http://www.exadel.com/products_products1.htm</td></tr></tbody></table></div></div></div></div></body></html>